<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE exercises SYSTEM "../csharpnotes1.dtd" >

<exercises>

<exercise>
<exercise-question><p>Write a subroutine that creates an ArrayList containing several <i>different</i>
random integers in the range from 1 up to some specified maximum.  The number of integers and the
maximum allowed value for the integers should be parameters to the subroutine.  Write a <code>main()</code>
routine to test your subroutine.</p>
</exercise-question>
<exercise-discuss><p>The exercise asks for an ArrayList containing integers. That has to mean
using <atype>ArrayList&lt;Integer&gt;</atype>, since an ArrayList can't contain values of
type <ptype>int</ptype>.  The problem is pretty easy: Start with an empty list,
then generate random integers and add them to the list until you have as many integers as you
want.  Since all the integers in the list must be different, before adding an integer to the
list, we need to test whether that integer is already in the list.  One way to do that is
with the <code>indexOf()</code> method from the ArrayList class.  If <code>numbers</code>
is an <atype>ArrayList&lt;Integer&gt;</atype> and <code>num</code> is an <ptype>int</ptype>,
then <code>numbers.indexOf(num)</code> returns -1 if <code>num</code> is <b>not</b> in the list.
(Note that this relies on autoboxing to convert <code>num</code> into an object of type
<classname>Integer</classname>, since <code>indexOf()</code> requires an object as its parameter.)
To create the list of numbers, we just add integers to the list until it reaches the desired size.
Assuming that <code>count</code> is the desired number of integers and <code>max</code> is the
maximum allowed value for the integers, this can be done with</p>
<pre>ArrayList&lt;Integer&gt; numbers = new ArrayList&lt;Integer&gt;();
while (numbers.size() &lt; count) {
    int num = (int)(Math.random()*max) + 1;
    if ( numbers.indexOf(num) == -1 )
        numbers.add( num );
}</pre>
<np>This code is the heart of the solution.  There is one problem, however.
If <code>count&nbsp;&gt;&nbsp;max</code>, then it's impossible to get <code>count</code>
different integers in the range from 1 to <code>max</code>, because there aren't that
many different numbers in the range!  In fact, the <code>while</code> loop will be
an infinite loop in that case since the size of the ArrayList can never become larger than
<code>max</code>.  My solution avoids the infinite loop by throwing
an <classname>IllegalArgumentException</classname> when <code>count&nbsp;&gt;&nbsp;max</code>.
You can see the complete subroutine, and a <code>main()</code> routine that tests it, below.</np>
<p>Note that an ArrayList in this program is simply printed using
<code>System.out.println()</code>.  The <code>toString()</code> method of the
<classname>ArrayList</classname> class will be called to get the <classname>String</classname>
representation of the list.  That method outputs the items from the list, enclosed between
<code>[</code> and <code>]</code> and separated by commas.</p>
</exercise-discuss>
<exercise-code>
<pre><prog name="SeveralRandomIntegers">import java.util.ArrayList;


public class SeveralRandomIntegers {
    
    /**
     * Creates an ArrayList that contains several integers chosen at
     * random from a specified range of values.  All the integers
     * in the list are different.
     * @param count  the number of random integers to be created
     * @param max  the integers are chosen in the range 1 to max, inclusive
     * @return an ArrayList containing the integers.  The integers are
     *    random and are in a random order.
     * @throws IllegalArgumentException if max is greater than count.  In
     *    that case there are fewer than count different integers in the
     *    range 1 to max.
     */
    public static ArrayList&lt;Integer&gt; makeRandomInts( int count, int max ) {
        if (count &gt; max) {
            throw new IllegalArgumentException("Can't have " + count + 
                    " different integers in the range  1 to " + max);
        }
        ArrayList&lt;Integer&gt; numbers = new ArrayList&lt;Integer&gt;();
        while (numbers.size() &lt; count) {
            int num = (int)(Math.random()*max) + 1;
            if ( numbers.indexOf(num) == -1 )
                numbers.add( num );
        }
        return numbers;
    }
    
    public static void main(String[] args) {
        System.out.println("10 integers chosen from the range 1 to 100:");
        for (int i = 0; i &lt; 8; i++)
            System.out.println( makeRandomInts(10,100) );
        System.out.println();
        System.out.println("10 integers chosen from the range 1 to 10:");
        for (int i = 0; i &lt; 3; i++)
            System.out.println( makeRandomInts(10,10) );
        System.out.println();
        System.out.println("25 integers chosen from the range 1 to 10000:");
        System.out.println( makeRandomInts(25,10000) );
        System.out.println();
        System.out.println("End with an exception!");
        makeRandomInts(10,9);
    }

}
</prog></pre>
</exercise-code>
</exercise>



<exercise>
<exercise-question><p>Suppose that <code>M</code> is a two-dimensional array that
has <code>R</code> rows and <code>C</code> columns.  The <newword>transpose</newword>
of <code>M</code> is defined to be an array <code>T</code> that has <code>C</code> rows
and <code>R</code> columns such that <code>T[i][j]&nbsp;=&nbsp;M[j][i]</code> for 
each <code>i</code> and <code>j</code>.  Write a function that takes an array
of type <atype>int[][]</atype> as a parameter, and returns the transpose of that array.
(Assume that the parameter is a typical 2D array in which all the rows have the same length.)
Also write a subroutine to print a 2D array of integers in neat rows and columns, and
include a <code>main()</code> routine to test your work.</p>
</exercise-question>
<exercise-discuss><p>To create the transpose, we need to know how many rows and
how many columns are in the original array.  As noted in <localref href="arrays.5.1"/>,
the number of rows in a 2D array <code>A</code> is given by <code>A.length</code>,
and the number of columns is <code>A[0].length</code>.  (<code>A[0].length</code> is
the length of the first row of <code>A</code>, which is the same as the number of
columns in <code>A</code>.  Remember that all rows have the same length.)  Given that,
we can create a transpose array of the correct size, and&mdash;with a little care to get
the indices right&mdash;we can copy all the items
from the original array into the transpose.  If <code>matrix</code> is the original
array, then the transpose can be created with</p>
<pre>int[][] transpose;
int R = matrix.length;     // the number of rows in matrix
int C = matrix[0].length;  // the number of columns in matrix
transpose = new int[C][R];
for ( int i = 0; i &lt; C; i++) { // goes through ROWS of the transpose
    for ( int j = 0; j &lt; R; j++ ) { // goes through COLUMNS of the transpose
        transpose[i][j] = matrix[j][i];
    }
}</pre>
<p>One other note of interest is in the code for printing the array.  See the 
comments on the source code below.</p>
<p>By the way, one purpose of this exercise was to remind you that arrays can be parameters and
they can be the return value of a function.  In this case, the parameter type
and the return type for the function are both given by <atype>int[][]</atype>.</p>
</exercise-discuss>
<exercise-code>
<pre><prog name="TransposeMatrix">
public class TransposeMatrix {
    
    /**
     * Creates the transpose of a given 2D array of integers.
     * @param matrix  the original array
     * @return the transpose of matrix
     */
    public static int[][] computeTranspose( int[][] matrix ) {
        int[][] transpose;
        int R = matrix.length;     // the number of rows in matrix
        int C = matrix[0].length;  // the number of columns in matrix
        transpose = new int[C][R];
        for ( int i = 0; i &lt; C; i++) { // goes through ROWS of the transpose
            for ( int j = 0; j &lt; R; j++ ) { // goes through COLUMNS of the transpose
                transpose[i][j] = matrix[j][i];
            }
        }
        return transpose;
    }
    
    /**
     * Prints out the items of a 2D array of ints in rows and columns,
     * with 6 spaces in each column.
     */
    public static void print( int[][] array ) {
            // Note that this uses a for-each loop where the loop
            // control variable is of type int[].  This works because
            // a 2D array is actually a 1D array of 1D arrays, where
            // each 1D array is one of the rows of the 2D array.
        for ( int[] row : array ) { 
                // print out one row from the array
            System.out.print("   ");
            for ( int item : row ) {
                   // print with 1 blank space and 5 spaces for the integer;
                   // if an integer needs more than 5 spaces, the columns will
                   // be messed up, but all the integers will still be readable.
                System.out.printf(" %5d", item); 
            }
            System.out.println();
        }
    }
    
    /**
     * Test the subroutines by creating two arrays and printing them and
     * their transposes.  The arrays are constructed so that it is easy
     * to see that the transposes are correct.
     */
    public static void main(String[] args) {
        int[][] orig = {
                { 1, 2, 3, 4, 5, 6 },
                { 10, 20, 30, 40, 50, 60 },
                { 100, 200, 300, 400, 500, 600 }
        };
        System.out.println("Original matrix:");
        System.out.println();
        print(orig);
        System.out.println();
        System.out.println("The transpose:");
        System.out.println();
        print( computeTranspose(orig) );
        System.out.println();
        System.out.println();

        orig = new int[][] {
                {1, 1, 1, 1, 1, 1, 1},
                {2, 2, 2, 2, 2, 2, 2},
                {3, 3, 3, 3, 3, 3, 3},
                {4, 4, 4, 4, 4, 4, 4},
                {5, 5, 5, 5, 5, 5, 5},
                {6, 6, 6, 6, 6, 6, 6},
                {7, 7, 7, 7, 7, 7, 7},
        };
        System.out.println("Original matrix:");
        System.out.println();
        print(orig);
        System.out.println();
        System.out.println("The transpose:");
        System.out.println();
        print( computeTranspose(orig) );
        System.out.println();

    }

}
</prog></pre>
</exercise-code>
</exercise>



<exercise>
<exercise-question><p>In <localref href="arrays.4.4"/>, it is mentioned that the
standard sorting method <code>Arrays.sort()</code> is much faster and efficient
than selection sort.  Write a program to test this claim.  To be specific, your
program should create a large array filled with random real numbers.  It should
use both <code>Arrays.sort()</code> and <code>selectionSort()</code> to sort
the array, and it should time how long it takes to perform each sort.  Furthermore,
it should do the same thing for a large array of random <classname>Strings</classname>.
To find the times, you can use <code>System.nanoTime()</code>
(see <localref href="basics.3.1"/> and the example <sourceref chapter="2" href="TimedComputation.java"/>).</p>
</exercise-question>
<exercise-discuss><p>This exercise is most interesting for the results of the timing
experiments, but one point of interest is how to make a "random string."  In my program, 
I make a string containing uppercase letters, with a random length:</p>
<pre>private static String randomString() {
    int length = 5 + (int)(21*Math.random());
    StringBuilder str = new StringBuilder();
    for (int i = 0; i &lt; length; i++) {
        char ch = (char)('A' + (int)(26*Math.random())); // a random letter
        str.append(ch);
    }
    return str.toString();
}</pre>
<np>This method is then used to fill an array with random strings.  I wrote methods for
creating random arrays of a given size.  I used <code>Arrays.copyOf()</code> to make
copies of the arrays.  I need two copies of each random array, since I
want to apply <code>selectionSort()</code> and <code>Arrays.sort()</code> to identical data.
So the arrays are created with</np>
<pre>numberList1 = randomNumbers(SIZE);
numberList2 = Arrays.copyOf(numberList1, SIZE);
stringList1 = randomStrings(SIZE);
stringList2 = Arrays.copyOf(stringList1, SIZE);
</pre>
<np>where <code>SIZE</code> is a constant.  (By using a constant here, I can easily adapt
the program to run with different array sizes.)</np>
<p>The selection sort algorithm is copied from <localref href="arrays.4.4"/>.  We actually need
two <code>selectionSort</code> methods, one to sort numbers an one to sort strings.
You will see that my program includes tests of those methods.  Without that test, I wouldn't
have been confident that my subroutines were sorting the arrays correctly.</p>
<p>The code for timing the sorting algorithms is straightforward.
Here are sort times from my program, running my computer:</p>  
<pre>Seconds to sort 100000 numbers with selectionSort: 3.39291
Seconds to sort 100000 numbers with Arrays.sort(): 0.0369317
Seconds to sort 100000 strings with selectionSort: 31.9331
Seconds to sort 100000 strings with Arrays.sort(): 0.0571503</pre>
<np>Note that <code>Arrays.sort()</code> is <b>much</b> faster than
<code>selectionSort</code>.  Also, it takes longer to sort strings that it takes to
sort numbers, since comparing two strings takes longer than comparing two numbers.
The advantage of <code>Arrays.sort()</code> is greater for strings than it is for numbers.
I'm not sure why that happens.</np>
<p>You can try running the program with different array sizes.  A large difference is
noticeable even for arrays of size 1000, although all of the times are rather short in that
case.  The advantage of <code>Arrays.sort()</code> increases as the array size increases.</p>
</exercise-discuss>
<exercise-code>
<pre><prog name="SortExperiments">import java.util.Arrays;

public class SortExperiments {
    
    final static int SIZE = 100000; // The length of arrays that will be sorted.
    
    /**
     * Creates a random string.  The length of the string is between 5 and 25,
     * and it is made up of randomly selected uppercase letters.
     */
    private static String randomString() {
        int length = 5 + (int)(21*Math.random());
        StringBuilder str = new StringBuilder();
        for (int i = 0; i &lt; length; i++) {
            char ch = (char)('A' + (int)(26*Math.random()));
            str.append(ch);
        }
        return str.toString();
    }
    
    /**
     * Creates an array of random real numbers.  The items in the array
     * are random numbers in the range 0.0 to 1.0.
     * @param count The length of the array that is created.
     */
    private static double[] randomNumbers(int count) {
        double[] numbers = new double[count];
        for (int i = 0; i &lt; count; i++)
            numbers[i] = Math.random();
        return numbers;
    }
    
    /**
     * Creates an array of random strings. The items in the
     * array are created by calling the function randomString();
     * @param count the size of the array that is created
     */
    private static String[] randomStrings(int count) {
        String[] strings = new String[count];
        for (int i = 0; i &lt; count; i++)
            strings[i] = randomString();
        return strings;
    }
    
    /**
     * Sort an array of real numbers using the selection sort algorithm.
     */
    private static void selectionSort(double[] numbers) {
        for (int top = numbers.length-1; top > 0; top-- ) {
            int maxloc = 0;
            for (int i = 1; i &lt;= top; i++) {
                if (numbers[i] > numbers[maxloc])
                    maxloc = i;
            }
            double temp = numbers[top];
            numbers[top] = numbers[maxloc];
            numbers[maxloc] = temp;
        }
    }
            
    /**
     * Sort an array of strings using the selection sort algorithm.
     */
    private static void selectionSort(String[] numbers) {
        for (int top = numbers.length-1; top > 0; top-- ) {
            int maxloc = 0;
            for (int i = 1; i &lt;= top; i++) {
                if (numbers[i].compareTo(numbers[maxloc]) > 0)
                    maxloc = i;
            }
            String temp = numbers[top];
            numbers[top] = numbers[maxloc];
            numbers[maxloc] = temp;
        }
    }
            
    public static void main(String[] args) {
        
        long startTime;  // time when a sort begin.
        long endTime;    // time when a sort ends.
        
        double[] numberList1;  // An array of random numbers.
        double[] numberList2;  // A copy of numberList1.
        
        String[] stringList1;  // An array of random strings.
        String[] stringList2;  // A copy of stringList1.
        
        /* Make sure the selection sort methods are correct.  The outputs
           should be correctly sorted. */
        
        System.out.println("First, test that selection sort works on doubles.");
        System.out.println("The 10 output numbers should be in increasing order.");
        numberList1 = randomNumbers(10);
        selectionSort(numberList1);
        for (double n : numberList1)
            System.out.println( "   " + n );
        System.out.println();
        
        System.out.println("Next, test that selection sort works on strings.");
        System.out.println("The 10 output strings should be in alphabetical order.");
        System.out.println("(Also tests that random strings are made correctly.");
        stringList1 = randomStrings(10);
        selectionSort(stringList1);
        for (String str : stringList1)
            System.out.println( "   " + str );
        System.out.println();
        
        System.out.println();
        System.out.println("Times for sorting arrays of size " + SIZE + ":");
        System.out.println();
        
        /* Create the arrays. */
        
        numberList1 = randomNumbers(SIZE);
        numberList2 = Arrays.copyOf(numberList1, SIZE);
        stringList1 = randomStrings(SIZE);
        stringList2 = Arrays.copyOf(stringList1, SIZE);
        
        /* Do the sorts and output the times. */
        
        startTime = System.nanoTime();
        selectionSort(numberList1);
        endTime = System.nanoTime();
        System.out.printf("Seconds to sort %d numbers with selectionSort: %1.6g%n",
                                SIZE, (endTime - startTime) / 1e9);
        
        startTime = System.nanoTime();
        Arrays.sort(numberList2);
        endTime = System.nanoTime();
        System.out.printf("Seconds to sort %d numbers with Arrays.sort(): %1.6g%n",
                                SIZE, (endTime - startTime) / 1e9);
        
        startTime = System.nanoTime();
        selectionSort(stringList1);
        endTime = System.nanoTime();
        System.out.printf("Seconds to sort %d strings with selectionSort: %1.6g%n",
                                SIZE, (endTime - startTime) / 1e9);
        
        startTime = System.nanoTime();
        Arrays.sort(stringList2);
        endTime = System.nanoTime();
        System.out.printf("Seconds to sort %d strings with Arrays.sort(): %1.6g%n",
                                SIZE, (endTime - startTime) / 1e9);
        System.out.println();
        
    }

}
</prog></pre>
</exercise-code>
</exercise>





<exercise>
<exercise-question><p>In <localref href="GUI1.ex.2"/>, you wrote a
program <code>DragTwoSquares</code> that allows the user to
drag a red square and a blue square around on a canvas.  Write a
much improved version where the user can add squares to a canvas
and drag them around.  In particular: If the user shift-clicks
or right-clicks the canvas, then the user is trying to drag a
square; find the square that contains the mouse position, if any,
and move it as the user drags the mouse.  Other clicks should
add squares.  You can place the center of the new square at
the current mouse position.  To make the picture more visually
appealing, give each square a random color, and when you draw
the squares, draw a black outline around each square.  (My program
also gives the square a random alpha value between 0.5 and 1.0).</p>
<p>Write a class to represent the data needed for drawing one square,
and use an <classname>ArrayList</classname> to store the data for
all the squares in the picture.  If the user drags a square 
completely off the canvas, delete it from the list.</p>
</exercise-question>
<exercise-discuss>
<p>We need three pieces
of information in order to draw a square:  its x-coordinate, its y-coordinate,
and its color.  We can pack the three pieces 
of information into a class:</p>
<pre>/**
 * A class to hold to hold the data for one square.
 */
private static class SquareData {
    double x,y;  // The coordinates of the center of the square.
    Color color; // The color of the square.
}</pre>
<np>The data for the whole collection of squares is then stored using an instance variable
named <code>squares</code> of type <atype>ArrayList&lt;SquareData&gt;</atype>.
By using an ArrayList, we allow for an unlimited number of squares.
(Note that since the xy coordinates will change when a square is dragged,
we cannot use a record class here.)</np>

<p>Given this data structure, it's easy to write a <fx><code>draw()</code></fx><swing><code>paintComponent()</code></swing>
method that completely redraws the contents of the canvas.  
It can use a for-each loop to go through the <classname>ArrayList</classname>.  
The loop control
variable, <code>squareData</code>, is of type <classname>SquareData</classname>, and 
the data needed to draw the square is given by its three instance variables
<code>squareData.x</code>, <code>squareData.y</code>, and <code>squareData.color</code>.
To draw a rectangle, we need the coordinates of the top-left corner of the square.
Since <code>squareData.x</code> and <code>squareData.y</code> are the coordinates
of the center of the square, we have to subtract half of the square size from
them to get the coordinates for the top-left corner.  In my program, the square size
is 100, so the drawing method can be written as follows:</p>

<fxdiv>
<pre>private void draw() {
    GraphicsContext g = canvas.getGraphicsContext2D();
    g.setFill(Color.rgb(230,255,230)); // light green background
    g.fillRect(0,0,canvas.getWidth(),canvas.getHeight());
    g.setLineWidth(2);
    g.setStroke(Color.BLACK);
    for ( SquareData squareData: squares ) {
        g.setFill( squareData.color );
        g.fillRect( squareData.x - 50, squareData.y - 50, 100, 100 );
        g.strokeRect( squareData.x - 50, squareData.y - 50, 100, 100 );
    }
}</pre>
</fxdiv>
<swingdiv>
<pre>public void paintComponent(Graphics g) {
    super.paintComponent(g);  // Fill with background color.
    for ( SquareData squareData: squares ) {
        g.setColor( squareData.color );
        g.fillRect( squareData.x - 50, squareData.y - 50, 100, 100);
        g.setColor( Color.BLACK );
        g.drawRect( squareData.x - 50, squareData.y - 50, 100, 100);
    }
}</pre>
</swingdiv>

<np>This method is called every time the mouse is moved while the user is dragging
a square.  It's not sufficient to draw the square in its new position&mdash;it must
be removed from its previous position, and the area that it previously occupied has to be
redrawn because it might contain other squares.  It is easiest, though not most efficient,
just to redraw the entire picture.  When the user adds a new square, it would be enough
to just draw the new square, but in fact my program just calls <code><fx>draw()</fx><swing>repaint()</swing></code>
in that case as well.</np>

<p>Another interesting point is in the <code>mousePressed()</code> routine, which
is called when the user clicks the mouse on the drawing area.  If the user shift-clicks or right-clicks, we have
to figure out which square contains the mouse position, so that we know which
square to drag.  To do that, we have to search the <classname>ArrayList</classname>
of squares to find one that meets the criterion that it contains the mouse
position.  (This is an example of linear search, as defined in <localref href="arrays.4.1"/>.)
There is a twist, since if there are two squares under the mouse, we want the one
that is on top, and that will be the one that comes later in the array.
So, we should search the list starting at the end and working towards the
beginning.  Then the first square that we encounter that contains the mouse
position is the one that we want:</p>

<pre>x = evt.getX();  // (x,y) is the point where the mouse was pressed
y = evt.getY();
for (int i = squares.size() - 1; i &gt;= 0; i--) {
    SquareData squareData = squares.get(i);
    double cx = squareData.x; // (cx,cy) is the center of the square
    double cy = squareData.y;
    if ( x &gt;= cx - 50 &amp;&amp; x &lt;= cx + 50 &amp;&amp; y &gt;= cy - 50 &amp;&amp; y &lt;= cy + 50) {
        dragging = true;
        draggedSquare = squareData;
        offsetX = x - cx;
        offsetY = y - cy;
        break;  // stop as soon as we find  square containing (x,y)
    }
}</pre>

<np>You can check out the sample solution below for other details.</np>
</exercise-discuss>
<exercise-code>
<pre><prog name="DragLotsOfSquares" scope="fx">import javafx.application.Application;
import javafx.stage.Stage;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.MouseButton;

import java.util.ArrayList;


/**
 * A program that lets the user add squares to a canvas by clicking.
 * The center of a square is placed at the point where the user clicked.
 * Squares all have the same size (100-by-100).  They have random
 * colors with up to 50% transparency.  If the user shift-clicks
 * or right-clicks a square, the user can drag the square.  If
 * the user drags a square off the canvas, it is deleted from the
 * list of squares.
 */
public class DragLotsOfSquares extends Application {

    public static void main(String[] args) {
        launch(args);
    }

    //---------------------------------------------------------------------
    
    /**
     * An object of type SquareData contains the data necessary to
     * draw one square, that is, the color of the square and the
     * coordinates of its center.
     */
    private static class SquareData {
        double x,y;  // Location of center of square.  The size is always 100-by-100.
        Color color; // The color of the square
    }


    private ArrayList&lt;SquareData&gt; squares;  // Info for all squares in the picture.

    private Canvas canvas;  // The canvas where the sqaures are drawn.


    /**
     *  The start method sets up the GUI.  It adds mouse event handlers to
     *  the canvas to implement adding and dragging squares.
     */
    public void start(Stage stage) {
        
        squares = new ArrayList&lt;SquareData&gt;();

        canvas = new Canvas(640,480);
        draw(); // Will just fill canvas with background color.
        
        canvas.setOnMousePressed( e -&gt; mousePressed(e) );
        canvas.setOnMouseDragged( e -&gt; mouseDragged(e) );
        canvas.setOnMouseReleased( e -&gt; mouseReleased(e) );
        
        Pane root = new Pane(canvas);
        
        Scene scene = new Scene(root);
        
        stage.setScene(scene);
        stage.setTitle("Click to add a square. Right-click to drag.");
        stage.setResizable(false);
        stage.show();
    } 


    /**
     * Draw the canvas, showing all squares in their current positions.
     */
    private void draw() {
        GraphicsContext g = canvas.getGraphicsContext2D();
        g.setFill(Color.rgb(230,255,230)); // light green
        g.fillRect(0,0,canvas.getWidth(),canvas.getHeight());
        g.setLineWidth(2);
        g.setStroke(Color.BLACK);
        for ( SquareData squareData: squares ) {
            g.setFill( squareData.color );
            g.fillRect( squareData.x - 50, squareData.y - 50, 100, 100);
            g.strokeRect( squareData.x - 50, squareData.y - 50, 100, 100);
        }
    }

    
    //-----------------  Variables and methods for responding to drags -----------

    private boolean dragging;      // Set to true when a drag is in progress.

    private SquareData draggedSquare;  // When a drag is in progress, this is 
                                       // the square that is being dragged.

    private double offsetX, offsetY;  // Offset of mouse-click coordinates from the
                                      //   center of the square that is being dragged.

    /**
     * Respond when the user presses the mouse on the canvas.
     * A shift-click or right-click starts dragging the square
     * under the mouse, if any.  Other clicks will add a new
     * square with its center at the mouse position.  A drag
     * operation is begun only if the user shift-clicks or
     * right-clicks a square.
     */
    public void mousePressed(MouseEvent evt) { 

        if (dragging)  // Exit if a drag is already in progress.
            return;

        double x = evt.getX();  // Location where user clicked.
        double y = evt.getY();

        if (evt.isShiftDown() || evt.getButton() == MouseButton.SECONDARY) {  
            // If user shift-clicked a square, start dragging it.
        
            /* Find the square, if any, that contains (x,y).  If several squares
             * contain (x,y), we want the one on top, which is the LAST one in
             * the list that contains (x,y) -- so consider the squares in the
             * reverse of their order in the list. */
            
            for (int i = squares.size() - 1; i &gt;= 0; i--) {
                SquareData squareData = squares.get(i);
                double cx = squareData.x; // (cx,cy) is the center of the square
                double cy = squareData.y;
                if ( x &gt;= cx - 50 &amp;&amp; x &lt;= cx + 50 &amp;&amp; y &gt;= cy - 50 &amp;&amp; y &lt;= cy + 50) {
                    dragging = true;
                    draggedSquare = squareData;
                    offsetX = x - cx;
                    offsetY = y - cy;
                    break;  // stop as soon as we find  square containing (x,y)
                }
            }
        }
        else { // Add a new square with center at (x,y)
            SquareData squareData = new SquareData();
            squareData.x = x;
            squareData.y = y;
                // Use a random color for the square.  Choose random RGB components
                // in the range 0.0 to 1.0 and a random alpha in the range 0.5 to 1.0.
                // This will make a square that can be somewhat transparent but not
                // too transparent.
            squareData.color = Color.color( 
                    Math.random(), Math.random(), Math.random(), 0.5 + 0.5*Math.random() );
            squares.add( squareData );
            draw();  // Redraw the whole picture to show the new square.
                     //  (Could have just drawn it here instead!)
        }
    }
    

    /**
     * Dragging stops when user releases the mouse button.  If the user
     * has dragged the square completely off the canvas, then it is deleted
     * from the list of squares. (That will have no visible effect on the
     * picture, so the canvas is not redrawn.)
     */
    public void mouseReleased(MouseEvent evt) { 
        if ( ! dragging )
            return;
        
        /* To test if the square has moved completely off the canvas,
         * test that its center is at least 50 pixels outside the canvas. */
        
        if (draggedSquare.x &gt; canvas.getWidth() + 50
                || draggedSquare.x &lt; -50
                || draggedSquare.y &gt; canvas.getHeight() + 50
                || draggedSquare.y &lt; -50) {
              // Square is completely off the canvas, so remove it!
            squares.remove(draggedSquare);
              // For testing, to make sure square is actually deleted:
            System.out.println("Removed square; list size = " + squares.size());
        }
        
        dragging = false;  // drag operation has ended.
        draggedSquare = null;
    }
    

    /**
     * Respond when the user drags the mouse.  If a square is 
     * not being dragged, then exit. Otherwise, change the position
     * of the square that is being dragged to match the position
     * of the mouse.  Note that the center of the square is placed
     * in the same relative position with respect to the mouse that it
     * had when the user started dragging it.
     */
    public void mouseDragged(MouseEvent evt) { 
        if ( ! dragging )  
            return;
        double x = evt.getX();
        double y = evt.getY();
        draggedSquare.x = x - offsetX;
        draggedSquare.y = y - offsetY;
        draw();  // Redraw picture to show square in new positions.
    }

} // end class DragLotsOfSquares
</prog></pre>
<pre><prog name="DragLotsOfSquares" scope="swing">import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.util.ArrayList;


/**
 * A program that lets the user add squares to a canvas by clicking.
 * The center of a square is placed at the point where the user clicked.
 * Squares all have the same size (100-by-100).  They have random
 * colors with up to 50% transparency.  If the user shift-clicks
 * or right-clicks a square, the user can drag the square.  If
 * the user drags a square off the canvas, it is deleted from the
 * list of squares.
 */
public class DragLotsOfSquares extends JPanel {


    /**
     * A main routine allows this class to be run as an application.
     */
    public static void main(String[] args) {
        JFrame window = new JFrame("Click to add; Shift-click to drag!");
        DragLotsOfSquares content = new DragLotsOfSquares();
        window.setContentPane(content);
        window.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        window.setLocation(120,70);
        window.setSize(600,450);
        window.setVisible(true);
    }

    //---------------------------------------------------------------------

    /**
     * An object of type SquareData contains the data necessary to
     * draw one square, that is, the color of the square and the
     * coordinates of its center.
     */
    private static class SquareData {
        int x,y;  // Location of center of square.  The size is always 100-by-100.
        Color color; // The color of the square
    }

    private ArrayList&lt;SquareData&gt; squares;  // Info for all squares in the picture.


    /**
     *  The constructor places the two squares in their initial positions and
     *  sets up listening for mouse events and mouse motion events.
     */
    public DragLotsOfSquares() {

        setBackground(new Color(200,255,200));  // Set up appearance of the panel
        setBorder(BorderFactory.createLineBorder(Color.BLACK, 2) );

        Dragger listener = new Dragger();  // Listening object, belonging to a nested
                                           //     class that is defined below.

        addMouseListener(listener);        // Set up listening.
        addMouseMotionListener(listener);
        
        squares = new ArrayList&lt;SquareData&gt;();
    } 


    /**
     * paintComponent just draws all the squares in their current positions.
     */
    public void paintComponent(Graphics g) {
        super.paintComponent(g);  // Fill with background color.
        for ( SquareData squareData: squares ) {
            g.setColor( squareData.color );
            g.fillRect( squareData.x - 50, squareData.y - 50, 100, 100);
            g.setColor( Color.BLACK );
            g.drawRect( squareData.x - 50, squareData.y - 50, 100, 100);
        }
    }


    /**
     *  This private class is used to define the listener that listens
     *  for mouse events and mouse motion events on the panel.
     */
    private class Dragger implements MouseListener, MouseMotionListener {

        /* Some variables used during dragging */

        boolean dragging;      // Set to true when a drag is in progress.

        SquareData draggedSquare;  // When a drag is in progress, this is 
                                   // the square that is being dragged.

        int offsetX, offsetY;  // Offset of mouse-click coordinates from the
                               //   center of the square that is being dragged.

        /**
         * Respond when the user presses the mouse on the panel.
         * A shift-click or right-click starts dragging the square
         * under the mouse, if any.  Other clicks will add a new
         * square with its center at the mouse position.  A drag
         * operation is begun only if the user shift-clicks or
         * right-clicks a square.
         */
        public void mousePressed(MouseEvent evt) { 

            if (dragging)  // Exit if a drag is already in progress.
                return;

            int x = evt.getX();  // Location where user clicked.
            int y = evt.getY();

            if (evt.isShiftDown() || evt.getButton() == MouseEvent.BUTTON3) {  
                // If user shift-clicked or right-clicked a square, start dragging it.
            
                /* Find the square, if any, that contains (x,y).  If several squares
                 * contain (x,y), we want the one on top, which is the LAST one in
                 * the list that contains (x,y) -- so consider the squares in the
                 * reverse of their order in the list. */
                
                for (int i = squares.size() - 1; i >= 0; i--) {
                    SquareData squareData = squares.get(i);
                    int cx = squareData.x; // (cx,cy) is the center of the square
                    int cy = squareData.y;
                    if ( x >= cx - 50 &amp;&amp; x &lt;= cx + 50 &amp;&amp; y >= cy - 50 &amp;&amp; y &lt;= cy + 50) {
                        dragging = true;
                        draggedSquare = squareData;
                        offsetX = x - cx;
                        offsetY = y - cy;
                        break;  // stop as soon as we find  square containing (x,y)
                    }
                }
            }
            else { // Add a new square with center at (x,y)
                SquareData squareData = new SquareData();
                squareData.x = x;
                squareData.y = y;
                int red = (int)(256*Math.random());
                int green = (int)(256*Math.random());
                int blue = (int)(256*Math.random());
                int alpha = 255 - (int)(128*Math.random());
                squareData.color = new Color(red,green,blue,alpha);
                squares.add( squareData );
                repaint();  // Redraw the whole picture to show the new square.
                            //  (Could have just drawn it here instead!)
            }
        }
        

        /**
         * Dragging stops when user releases the mouse button.  If the user
         * has dragged the square completely off the canvas, then it is deleted
         * from the list of squares. (That will have no visible effect on the
         * picture, so the canvas is not redrawn.)
         */
        public void mouseReleased(MouseEvent evt) { 
            if ( ! dragging )
                return;
            if (draggedSquare.x > getWidth() + 50
                    || draggedSquare.x &lt; -50
                    || draggedSquare.y &gt; getHeight() + 50
                    || draggedSquare.y &lt; -50) {
                  // Square is completely off the canvas, so remove it!
                squares.remove(draggedSquare);
                  // For testing, to make sure square is actually deleted:
                System.out.println("Removed square; list size = " + squares.size());
            }
            dragging = false;  // drag operation has ended.
            draggedSquare = null;
        }
        

        /**
         * Respond when the user drags the mouse.  If a square is 
         * not being dragged, then exit. Otherwise, change the position
         * of the square that is being dragged to match the position
         * of the mouse.  Note that the center of the square is placed
         * in the same relative position with respect to the mouse that it
         * had when the user started dragging it.
         */
        public void mouseDragged(MouseEvent evt) { 
            if ( ! dragging )  
                return;
            int x = evt.getX();
            int y = evt.getY();
            draggedSquare.x = x - offsetX;
            draggedSquare.y = y - offsetY;
            repaint();  // Redraw picture to show square in new positions.
        }

        public void mouseMoved(MouseEvent evt) { }  // empty methods required by interfaces.
        public void mouseClicked(MouseEvent evt) { }
        public void mouseEntered(MouseEvent evt) { }
        public void mouseExited(MouseEvent evt) { }

    } // end nested class Dragger


} // end class DragTwoSquaresPanel
</prog></pre>
</exercise-code>
</exercise>


<exercise>
<exercise-question><p>Write a program that will
read a sequence of positive real numbers entered by the user and will print the
same numbers in sorted order from smallest to largest. The user will input a
zero to mark the end of the input. Assume that at most 100 positive numbers
will be entered.  Do <b>not</b> use any built-in function such as 
<code>Arrays.sort()</code>. Do the sorting yourself.</p>
</exercise-question>
<exercise-discuss><p>The sample program 
<sourceref href="ReverseWithDynamicArray.java"/> from
<localref href="arrays.2.4"/> reads in up to 100 positive integers from the
user and outputs them in the reverse of the order in which the user entered
them. This is similar to what we have to do for this exercise, except that the
numbers we have to read are real numbers (of type <ptype>double</ptype>) and they
have to be output in sorted order.</p>

<p>There are two basic approaches to this problem. The first is to store all
the numbers in an array in the order in which they are input. After all the
numbers have been input, the array can be sorted, and then the contents of the
array can be output. The second approach is to always keep the array in sorted
order as numbers are added to it. When a new number is input, that number must
be inserted into its correct location in the array, in order to keep the array
sorted. After all the numbers have been input, the contents of the array are
ready to be printed.</p>

<p>Two solutions to the exercise, based on these two approaches, are shown
below. They use techniques for sorting and inserting that were covered in
<localref href="arrays.4"/>. In my first program, I've chosen to use
Selection Sort to sort the array. Insertion Sort would work just as well. The
Selection Sort subroutine is taken from <localref href="arrays.4"/> with two changes: It sorts
an array of <ptype>double</ptype> values instead of an array of <code>ints</code>, and it
has been modified to work with a "partially full" array. In order to make the
subroutine work with a partially full array, it is necessary to add a parameter
that tells the subroutine how many entries in the array are in use. The
modified Selection Sort routine is as follows, with changes from the original
version shown in &newcodestyle;</p>

<pre>static void selectionSort(<newcode>double</newcode>[] A, <newword>int count</newword>) {
      // Sort the numbers in A[0], A[1], ..., A[count-1] into
      // increasing order using Selection Sort.
   for ( int lastPlace = <newcode>count</newcode> - 1; lastPlace &gt; 0; lastPlace-- ) {
      int maxLoc = 0;
      for (int j = 1; j &lt;= lastPlace; j++) {
         if (A[j] &gt; A[maxLoc]) {
            maxLoc = j;
         }
      }
      <newcode>double</newcode> temp = A[maxLoc];
      A[maxLoc] = A[lastPlace];
      A[lastPlace] = temp;
   }
} // end selectionSort</pre>

<np>In the first version of the program, this subroutine is called just after
all the numbers have been input from the user.</np>

<p>The second version of the program is straightforward. It uses the
<code>insert()</code> subroutine from <localref href="arrays.4"/>, modified to work with an array
of <code>doubles</code> instead of an array of <code>ints</code>.</p>
</exercise-discuss>
<exercise-code><p><b>First solution, with Selection Sort:</b>
</p>

<pre><prog name="SortInputNumbers">import textio.TextIO;

    /**
     * This program reads up to 100 positive integers from the user and 
     * prints them in sorted order.  Input ends when the user enters a 
     * non-positive integer.  The numbers are read and stored in an array.
     * That array is sorted using selection sort, and then the array is
     * printed.
     */
    
    public class SortInputNumbers {
    
       public static void main(String[] args) {
      
          double[] numbers;  // An array for storing the input values.
          int numCt;         // The number of numbers saved in the array.
          double num;        // One of the numbers input by the user.
        
          numbers = new double[100];   // Space for 100 numbers.
          numCt = 0;                   // No numbers have been saved yet.
        
          System.out.println("Enter up to 100 positive numbers; Enter 0 to end");
        
          while (true) {   // Get the numbers and put them in the array.
             System.out.print("? ");
             num = TextIO.getlnDouble();
             if (num &lt;= 0)
                break;
             numbers[numCt] = num;
             numCt++;
          }
          
          selectionSort(numbers, numCt);  // Sort the numbers.
        
          System.out.println("\nYour numbers in sorted order are:\n");
        
          for (int i = 0; i &lt; numCt; i++) {
              System.out.println( numbers[i] );
          }
        
       } // end main();
       
       /**
        * Sort the numbers in A[0], A[1], ..., A[count-1] into
        * increasing order using Selection Sort.
        */
       static void selectionSort(double[] A, int count) {
          for ( int lastPlace = count - 1; lastPlace &gt; 0; lastPlace-- ) {
             int maxLoc = 0;
             for (int j = 1; j &lt;= lastPlace; j++) {
                if (A[j] &gt; A[maxLoc]) {
                   maxLoc = j;
                }
             }
             double temp = A[maxLoc];
             A[maxLoc] = A[lastPlace];
             A[lastPlace] = temp;
          }
       } // end selectionSort
      
    }  // end class SortInputNumbers
</prog></pre>

<p><b>Second solution, with Insert:</b>
</p>

<pre><prog name="SortInputNumbers2">import textio.TextIO;

/**
 * This program reads up to 100 positive integers from the user and 
 * prints them in sorted order.  Input ends when the user enters a
 * non-positive integer.  The numbers are read and inserted into
 * an array.  The array is maintained at all times in sorted order.
 */

public class SortInputNumbers2 {

   public static void main(String[] args) {
  
      double[] numbers;  // An array for storing the input values.
      int numCt;         // The number of numbers saved in the array.
      double num;        // One of the numbers input by the user.
    
      numbers = new double[100];   // Space for 100 numbers.
      numCt = 0;                   // No numbers have been saved yet.
    
      System.out.println("Enter up to 100 positive numbers; Enter 0 to end");
    
      while (true) {   // Get the numbers and insert them into the array.
         System.out.print("? ");
         num = TextIO.getlnDouble();
         if (num &lt;= 0)
            break;
         <newcode>insert(numbers, numCt, num);</newcode>
         numCt++;
      }
      
      System.out.println("\nYour numbers in sorted order are:\n");
    
      for (int i = 0; i &lt; numCt; i++) {
          System.out.println( numbers[i] );
      }
    
   } // end main();
   
   /**
    * Assume that A contains itemsInArray in increasing order.
    * Insert newItem into its correct position in the sorted array.
    */
   static void insert(double[] A, int itemsInArray, double newItem) {
      int loc = itemsInArray - 1;
      while (loc &gt;= 0 &amp;&amp; A[loc] &gt; newItem) {
             // Move the item from A[loc] up one space.
         A[loc + 1] = A[loc];
         loc = loc - 1;
      }
      A[loc + 1] = newItem;  // Put newItem in the last vacated space.
   } // end insert
  
}  // end class SortInputNumbers2
</prog></pre>
</exercise-code>
</exercise>   

   
   
<exercise id="arrays.ex.6">
<exercise-question><p>Write a program that will read a text file selected by the user,
and will make an alphabetical list of all the different words in that file.  All words
should be converted to lower case, and duplicates should be eliminated from the list.
The list should be written to an output file selected by the user.  As discussed
in <localref href="basics.4.4"/>, you can use <classname>TextIO</classname> to read and
write files.  Use a variable of type <atype>ArrayList&lt;String&gt;</atype> to
store the words.  It is not easy to separate a file into words as you are reading
it, especially if you want to allow apostrophes in the middle of a word.  
You can use the following method in your program:</p>
<pre>/**
 * Read the next word from TextIO, if there is one.  First, skip past
 * any non-letters in the input.  If an end-of-file is encountered before 
 * a word is found, return null.  Otherwise, read and return the word.
 * A word is defined as a sequence of letters.  Also, a word can include
 * an apostrophe if the apostrophe is surrounded by letters on each side.
 * @return the next word from TextIO, or null if an end-of-file is 
 *     encountered
 */
private static String readNextWord() {
   char ch = TextIO.peek(); // Look at next character in input.
   while (ch != TextIO.EOF &amp;&amp; ! Character.isLetter(ch)) {
          // Skip past non-letters.
      TextIO.getAnyChar();  // Read the character.
      ch = TextIO.peek();   // Look at the next character.
   }
   if (ch == TextIO.EOF) // Encountered end-of-file
      return null;
   // At this point, we know the next character is a letter, so read a word.
   String word = "";  // This will be the word that is read.
   while (true) {
      word += TextIO.getAnyChar();  // Append the letter onto word.
      ch = TextIO.peek();  // Look at next character.
      if ( ch == '\'' ) {
            // The next character is an apostrophe.  Read it, and
            // if the following character is a letter, add both the
            // apostrophe and the letter onto the word and continue
            // reading the word.  If the character after the apostrophe
            // is not a letter, the word is done, so break out of the loop.
         TextIO.getAnyChar();   // Read the apostrophe.
         ch = TextIO.peek();    // Look at char that follows apostrophe.
         if (Character.isLetter(ch)) {
            word += "\'" + TextIO.getAnyChar();
            ch = TextIO.peek();  // Look at next char.
         }
         else
            break;
      }
      if ( ! Character.isLetter(ch) ) {
            // If the next character is not a letter, the word is
            // finished, so break out of the loop.
         break;
      }
      // If we haven't broken out of the loop, next char is a letter.
   }
   return word;  // Return the word that has been read.
}</pre>
<np>Note that this method will return <code>null</code> when the file has been
entirely read.  You can use this as a signal to stop processing the input file.</np>
</exercise-question>
<exercise-discuss><p>This is actually not a very difficult program to write.
The main point of the exercise is to get you to use a list of strings and
to do something with files.</p>
<p>There are several possible approaches to this problem.  One approach is to simply dump
all the words from the file into a list, without worrying about eliminating
duplicates or keeping the list in order.  After the file has been read, the list
can be sorted and printed.  Although the list can contain duplicates, the output
file should list each word only once.  However, it's easy to leave out the duplicates
as the file is being written.  If <code>wordList</code> is the variable of
type <atype>ArrayList&lt;String&gt;</atype> that holds the already sorted list of words,
then the following code will output the list without duplicates.  The idea is
that a word is written only if it is different from the previous word in the list.
Word number 0 is a special case, because there is no previous location in the list
in that case:</p>
<pre>for (int i = 0; i &lt; wordlist.size(); i++) {
   if (i == 0 || ! wordlist.get(i).equals(wordList.get(i-1) )  
      System.out.println(wordlist.get(i));
}</pre>
<np>This is actually the most efficient of the three solutions that I discuss, as
long as the sorting is done with an efficient method.  (For arrays, sorting
can be done using <code>Arrays.sort()</code>.  I haven't discussed a similar
method for <classname>ArrayLists</classname>, but an <atype>ArrayList&lt;String&gt;</atype>
can be sorted using a static method <code>Collections.sort(list)</code> from the
class <code>java.util.Collections</code>.)</np>
<p>A second approach to the problem would be to keep the list of words in sorted
order as it is being constructed.  This can be done by applying the <code>insert()</code>
routine from <localref href="arrays.4.3"/> to insert each word into the list.</p>
<p>A third approach, and the one that I use in my solution, is to eliminate duplicates
from the list as it being constructed.  Each time a word is read from the input file,
I first check whether the word is already in the list.  If so, I discard it; if not,
I add it to the end of the list.  The function <code>wordList.indexOf(word)</code>
can be used to test whether a given word is already in the list; this function returns
the value <code>-1</code> if <code>word</code> is not in the list.  After the
input file has been read, the list contains one copy of each word that was found
in the file.  At this point the list still has to be sorted.  I use a
selection sort algorithm (<localref href="arrays.4.4"/>), adapted to work for an <classname>ArrayList</classname>, 
to do the sorting. Then, all the elements of the list are output using a for-each loop:</p>
<pre>for (String w : wordList)
   TextIO.putln("   " + w);</pre>
<p>To let the user select the input and the output files, I use the methods
<code>TextIO.readUserSelectedFile()</code> and <code>TextIO.writeUserSelectedFile()</code>,
which are discussed in <localref href="basics.4.4"/>.  These methods put up a file
dialog where the user can select a file.  After the user selects an input file, <code>TextIO</code>
reads from that file instead of from the user's input.  After the user selects an output
file, <code>TextIO</code> writes to that file instead of to standard output.
If the user cancels the input file dialog,  then there is no input file to process, 
so I exit the program.  If the user cancels the output file dialog, I write the list of
words anyway&mdash;it will go to standard output so the user will see it on the screen.</p>
<p>When <code>TextIO</code> is working with files and an error occurs, it will generate
an error of type <classname>IllegalArgumentException</classname>.  My program catches
the error if one occurs, and it prints an error message. An error is not very likely
in this case but one could occur if, for example, the user selects an input file that
the user does not have permission to read.</p>
<p>The complete code for my solution is shown below.</p>
</exercise-discuss>
<exercise-code>
<pre><prog name="ListAllWordsFromFile">import java.util.ArrayList;
import textio.TextIO;

/**
 * Makes an alphabetical list of all the words in a file selected
 * by the user.  The list can be written to a file.
 */
public class ListAllWordsFromFile {
   
   
   public static void main(String[] args) {
      
      System.out.println("""
                 This program will ask you to select an input file
              It will read that file and make an alphabetical
              list of all the words in the file.  After reading
              the file, the program asks you to select an output
              file.  If you select a file, the list of words will
              be written to that file; if you cancel, the list
              be written to standard output.  All words are converted
              to lower case, and duplicates are eliminated from the list.
              
              Press return to begin.
              
              """);

      TextIO.getln();  // Wait for user to press return.
      
      try {
         if (TextIO.readUserSelectedFile() == false) {
            System.out.println("No input file selected.  Exiting.");
             System.exit(1);
         }
         ArrayList&lt;String&gt; wordList = new ArrayList&lt;String&gt;();
         String word = readNextWord();
         while (word != null) {
            word = word.toLowerCase();  // convert word to lower case
            if ( wordList.indexOf(word) == -1 ) {
                  // This is a new word, so add it to the list
               wordList.add(word);
            }
            word = readNextWord();
         }
         System.out.println("Number of different words found in file:  " 
               + wordList.size());
         System.out.println();
         if (wordList.size() == 0) {
            System.out.println("No words found in file.");
            System.out.println("Exiting without saving data.");
            System.exit(0);
         }
         selectionSort(wordList);
         TextIO.writeUserSelectedFile(); // If user cancels, output automatically
                                         // goes to standard output.
         TextIO.putln(wordList.size() + " words found in file:\n");
         for (String w : wordList)
            TextIO.putln("   " + w);
         System.out.println("\n\nDone.\n\n");
      }
      catch (Exception e) {
         System.out.println("Sorry, an error has occurred.");
         System.out.println("Error Message:  " + e.getMessage());
      }
      System.exit(0);  // Might be necessary, because of use of file dialogs.
   }


   /**
    * Sorts a list of strings into lexicographical order, using
    * selection sort and treating the list much like an array.  In this 
    * program, the list only contains words made up of lower case
    * letters, so lexicographic order is the same as alphabetical order.
    */
   private static void selectionSort(ArrayList&lt;String&gt; list) {
      for (int top = list.size() - 1; top &gt; 0; top--) {
         int indexOfBiggest = 0;
         for (int j = 0; j &lt; top; j++) {
            String str = list.get(j);
            if (str.compareTo( list.get(indexOfBiggest) ) > 0) {
               indexOfBiggest = j;
            }
         }
         String temp = list.get(top);
         list.set( top, list.get(indexOfBiggest) );
         list.set( indexOfBiggest, temp );
      }
   }


   /**
    * Read the next word from TextIO, if there is one.  First, skip past
    * any non-letters in the input.  If an end-of-file is encountered before 
    * a word is found, return null.  Otherwise, read and return the word.
    * A word is defined as a sequence of letters.  Also, a word can include
    * an apostrophe if the apostrophe is surrounded by letters on each side.
    * @return the next word from TextIO, or null if an end-of-file is encountered
    */
   private static String readNextWord() {
      char ch = TextIO.peek(); // Look at next character in input.
      while (ch != TextIO.EOF &amp;&amp; ! Character.isLetter(ch)) {
             // Skip past non-letters.
         TextIO.getAnyChar();  // Read the character.
         ch = TextIO.peek();   // Look at the next character.
      }
      if (ch == TextIO.EOF) // Encountered end-of-file
         return null;
      // At this point, we know that the next character, so read a word.
      String word = "";  // This will be the word that is read.
      while (true) {
         word += TextIO.getAnyChar();  // Append the letter onto word.
         ch = TextIO.peek();  // Look at next character.
         if ( ch == '\'' ) {
               // The next character is an apostrophe.  Read it, and
               // if the following character is a letter, add both the
               // apostrophe and the letter onto the word and continue
               // reading the word.  If the character after the apostrophe
               // is not a letter, the word is done, so break out of the loop.
            TextIO.getAnyChar();   // Read the apostrophe.
            ch = TextIO.peek();    // Look at char that follows apostrophe.
            if (Character.isLetter(ch)) {
               word += "\'" + TextIO.getAnyChar();
               ch = TextIO.peek();  // Look at next char.
            }
            else
               break;
         }
         if ( ! Character.isLetter(ch) ) {
               // If the next character is not a letter, the word is
               // finished, so break out of the loop.
            break;
         }
         // If we haven't broken out of the loop, next char is a letter.
      }
      return word;  // Return the word that has been read.
   }
   
} // end ListAllWordsFromFile
</prog></pre>
</exercise-code>
</exercise>
   
   

<exercise>
<exercise-question><p>The game of Go Moku (also
known as Pente or Five Stones) is similar to Tic-Tac-Toe, except that it is played
on a much larger board and the object is to get five squares in a row rather
than three.  The board should have 13 rows and 13 columns of squares.
Players take turns placing pieces on a board. A piece can be placed
in any empty square. The first player to get five pieces in a row&mdash;horizontally, 
vertically, or diagonally&mdash;wins. If all squares are filled
before either player wins, then the game is a draw. Write a program that lets
two players play Go Moku against each other.</p>

<p>Your program will be simpler than the <classname>Checkers</classname> program from
<localref href="arrays.5.3"/>. Play alternates strictly between the two players,
and there is no need to highlight the legal moves. You will only need one
nested subclass, a subclass of <fx><classname>Canvas</classname></fx><swing><classname>JPanel</classname></swing> to draw
the board and do all the work of the game, like the nested 
<fx><classname>CheckersBoard</classname></fx><swing><classname>Board</classname></swing> class
in the <classname>Checkers</classname> program.  You will probably want
to look at the source code for the checkers program,
<sourceref href="Checkers.java"/>, for ideas about the general
outline of the program.</p>

<p>The hardest part of the program is checking whether the move that a player
makes is a winning move. To do this, you have to look in each of the four
possible directions from the square where the user has placed a piece. You have
to count how many pieces that player has in a row in that direction. If the
number is five or more in any direction, then that player wins. As a hint, here
is part of the code from my program. This code counts the number of pieces that
the user has in a row in a specified direction. The direction is specified by
two integers, <code>dirX</code> and <code>dirY</code>. The values of these variables
are 0, 1, or -1, and at least one of them is non-zero. For example, to look in
the horizontal direction, <code>dirX</code> is 1 and <code>dirY</code> is 0.</p>

<pre>int ct = 1;  // Number of pieces in a row belonging to the player.

int r, c;    // A row and column to be examined

r = row + dirX;  // Look at square in specified direction.
c = col + dirY;
while ( r &gt;= 0 &amp;&amp; r &lt; 13 &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; 13 
                                  &amp;&amp; board[r][c] == player ) {
        // Square is on the board, and it 
        // contains one of the player's pieces.
   ct++;
   r += dirX;  // Go on to next square in this direction.
   c += dirY;
}

r = row - dirX;  // Now, look in the opposite direction.
c = col - dirY;
while ( r &gt;= 0 &amp;&amp; r &lt; 13 &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; 13 
                                 &amp;&amp; board[r][c] == player ) {
   ct++;
   r -= dirX;   // Go on to next square in this direction.
   c -= dirY;
}</pre>

<p>Here is a picture of my program, just after black has won the game.</p>

<img src="gomoku-board.png" width="400" height="336" alt="gomoku game showing a winning position"
    tex="gomoku-board" texscale="0.6"/>

</exercise-question>
<exercise-discuss><p>This is a fairly complicated program, but it's possible to design and build
it in stages, testing each stage separately. The first stage, the general
layout of the panel, is already done in the 
<sourceref href="Checkers.java"/> program. With just a few changes, the
main <swing>panel</swing><fx>canvas</fx> class, the layout of the board, and the button and message
handling come directly from that program. Let's take the rest of the Go&nbsp;Moku
game one stage at a time.</p>

<p>A two-dimensional array is used to store the contents of the board. This
array is of type <atype>int[][]</atype> and is named <code>board</code>. It is defined as
an instance variable in the 
<swing><classname>Board</classname></swing><fx><classname>GoMokuBoard</classname></fx>
class, and it is initialized
in the constructor of that class to be a 13-by-13 array. The value in each
position of the array is one of three constants: <code>EMPTY</code>,
<code>WHITE</code>, or <code>BLACK</code>. When a game begins, each of the entries in
the array is set to empty. When a player clicks on an empty square, the
corresponding entry in the array is changed from <code>EMPTY</code> to 
<code>BLACK</code> or <code>WHITE</code>, depending on which player placed the piece. 
In the <code>drawBoard()</code>
method, the contents of the <code>board</code> array are used to decide what pieces
to draw on the board.</p>



<np><b><u>Drawing the Board</u></b></np>

<p>We need a <code><fx>drawBoard()</fx><swing>paintComponent()</swing></code> 
method for the board class that
can draw the board. The board has 13 rows and 13 columns of spaces. How wide
should the board be? If each square in the board is <code>x</code> pixels wide, we
need a total of <code>13*x</code> pixels just for the spaces. But there are also
lines between the spaces and at the edges of the board. I make each line two pixels wide, so the 14 lines
require another 28 pixels.  So, with
squares of side <code>x</code>, we need a board that is <code>13*x+28</code> pixels
wide. Since I wanted something about the same size as the original
checkerboard, which was 324 pixels, I choose <code>x</code> to be 22, giving a board width of 314 pixels. The
height is also 314.</p>

<p>The left edge of the <code>col</code>-th column of squares in the board is
<code>2+24*col</code>. This allows for the two-pixel border on the left and for 24
pixels for each of the preceding columns of squares. (That's 22 pixels for the
square plus two pixels for the line between that column and the next.) The lines
at <code>x</code> values <code>1&nbsp;+&nbsp;24*i</code>, for <code>i</code> from 0 to 13. 
This puts the center of the pen that is used to draw the line in the correct position,
one pixel to the left of each column for the first 13 lines, and one pixel from the right edge of the canvas
for the final line.   Rows work the
same way. To draw a piece in row number <code>row</code> and column number
<code>col</code>, the command</p>

<pre>g.fillOval(4 + 24*col, 4 + 24*row, 18, 18);</pre>

<np>can be used. This allows a two-pixel gap between the oval that represents
that piece and the side of the square.  Since the size of the square is 22 and there
is a 2-pixel gap on each side of the oval, the size of the oval is 22 minus 4, or 18. 
In my program, I defined a <code>drawPiece()</code> method to draw a piece.</np>

<p>The <code><fx>drawBoard()</fx><swing>paintComponent()</swing></code> method 
fills the canvas with light gray<swing> (by calling <code>super.paintComponent(g)</code>)</swing>.
It then draws the black lines between the squares, and draws all the pieces that
have been placed on the board. Remember that the piece in a
given row and column is recorded in the <code>board</code> array as
<code>board[row][col]</code>. This is done as follows:</p>

<pre>/* Draw lines separating the square and along the edges of the canvas.  */

 g.set<fx>Stroke</fx><swing>Color</swing>(Color.BLACK);
 for (int i = 0; i &lt;= 13; i++) {
     g.<fx>stroke</fx><swing>draw</swing>Line(1 + 24*i, 0, 1 + 24*i, 314);
     g.<fx>stroke</fx><swing>draw</swing>Line(0, 1 + 24*i, 314, 1 + 24*i);
 }

 /* Draw the pieces that are on the board. */

 for (int row = 0; row &lt; 13; row++)
     for (int col = 0; col &lt; 13; col++)
         if (boardData[row][col] != EMPTY)
             drawPiece(g, boardData[row][col], row, col);</pre>

<break/>

<np><b><u>Playing the Game</u></b></np>

<p>The logic of the GoMoku game itself is mostly in the method "<code>void
doClickSquare(int row, int&nbsp;col)</code>", which is called by the
<code>mousePressed()</code> method when the user clicks on the square in row number
<code>row</code> and column number <code>col</code>. This method must check whether the
move is legal. If so, the move is made. The method then checks whether the move
wins the game. If so, the game ends. The game will also end if the board has
become completely full. Otherwise, play passes to the other player.</p>

<p>The current player is recorded in an instance variable named
<code>currentPlayer</code>. The value of this variable is one of the two constants
<code>WHITE</code> or <code>BLACK</code>. The game can be ended by calling a method
named <code>gameOver()</code>. I wrote a <ptype>boolean</ptype>-valued method called
<code>winner()</code> to check whether a move wins the game. (When I first wrote
this method, it did nothing but "<code>return false</code>". This let me try out
the program at this stage of development, before I started working on the
difficult problem of testing for a winner.) The <code>doClickSquare()</code> method
can be written:</p>

<pre>void doClickSquare(int row, int col) {

    /* Check that the user clicked an empty square.  If not, show an
      error message and exit. */

    if ( boardData[row][col] != EMPTY ) {
        if (currentPlayer == BLACK)
            message.setText("BLACK:  Please click an empty square.");
        else
            message.setText("WHITE:  Please click an empty square.");
        return;
    }

    /* Make the move.  Check if the board is full or if the move
      is a winning move.  If so, the game ends.  If not, then it's
      the other user's turn.  If there is a winner, call
      drawWinLine() to mark the winning pieces. */

    boardData[row][col] = currentPlayer;  // Make the move.
    <fx>drawBoard();</fx><swing>repaint();</swing>

    if (winner(row,col)) {  // First, check for a winner.
        if (currentPlayer == WHITE)
            gameOver("WHITE wins the game!");
        else
            gameOver("BLACK wins the game!");<fx>
        drawWinLine();</fx>
        return;
    }

    boolean emptySpace = false;     // Check if the board is full.
    for (int i = 0; i &lt; 13; i++)
        for (int j = 0; j &lt; 13; j++)
            if (boardData[i][j] == EMPTY)
                emptySpace = true;
    if (emptySpace == false) {
        gameOver("The game ends in a draw.");
        return;
    }

    /* Continue the game.  It's the other player's turn. */

    if (currentPlayer == BLACK) {
        currentPlayer = WHITE;
        message.setText("WHITE:  Make your move.");
    }
    else {  
        currentPlayer = BLACK;
        message.setText("BLACK:  Make your move.");
    }

}  // end doClickSquare()</pre>

<np>Note that when the move wins the game, <fx>the method <code>drawWinLine()</code> is called.
This</fx><swing>the <code>paintComponent() method</code></swing> will 
draw a red line through the winning pieces.  <swing>You might notice that
in <code>doClickSquare()</code>, <code>repaint()</code> is called before the
<code>gameOver()</code> method is called.  It's important to realize that
<code>repaint()</code> does not call <code>paintComponent()</code>, it just
schedules it to be called later, and that won't happen until after the
<code>doClickSquare()</code> method has finished.</swing><fx>Unlike every other part of the
board, the red line is not drawn by <code>drawBoard()</code>.  It is added when the
game is over, and it will stay there until the board is erased at the beginning of the
new game.  Note that this violates my general policy that a <code>draw()</code> method
should completely reflect the state of the game.  In this case, it does not draw
the red line when the state of the game is that the game has been won.  This is OK
only because <code>drawBoard()</code> is never called when the game is in that state.</fx></np>

<break/>

<np><b><u>Determining the Winner</u></b></np>

<p>The <code>winner()</code> method is certainly the hardest part of the program.
The method must look in each of the four possible directions from the square
where the user has placed a piece. If the player has five or more pieces in a
row in that direction, then the player has won. As indicated in the exercise, a
direction can be indicated by two variables, <code>dirX</code> and <code>dirY</code>.
The values of these variables for each of the four directions are:</p>

<pre>                      dirX    dirY    Why?
                      ----    ----    --------------------------------
horizontal direction    1       0       Only x changes.
vertical direction      0       1       Only y changes.
falling diagonal        1       1       Both x and y change.
rising diagonal         1      -1       Change in opposing directions.</pre>

<p>I wrote a method "<code>int count(int player, int row, int col, int dirX, int
dirY)</code> that counts the number of pieces the specified player has in a row,
starting from the square in row number <code>row</code> and column number
<code>col</code> and looking in the direction indicated by <code>dirX</code> and
<code>dirY</code>. This method contains the code given in the exercise. It returns
the number of pieces found. My <code>winner</code> method just calls this method
for each of the four directions:</p>

<pre>/**
 * This is called just after a piece has been played on the
 * square in the specified row and column.  It determines
 * whether that was a winning move by counting the number
 * of squares in a line in each of the four possible
 * directions from (row,col).  If there are 5 squares (or more)
 * in a row in any direction, then the game is won.
 */
private boolean winner(int row, int col) {
     
   if (count( board[row][col], row, col, 1, 0 ) &gt;= 5)
      return true;
   if (count( board[row][col], row, col, 0, 1 ) &gt;= 5)
      return true;
   if (count( board[row][col], row, col, 1, -1 ) &gt;= 5)
      return true;
   if (count( board[row][col], row, col, 1, 1 ) &gt;= 5)
      return true;
      
   /* When we get to this point, we know that the game is not won. */

   return false;
   
}  // end winner()</pre>

<p>When I first wrote this method, I checked whether the number of pieces was
"<code>== 5</code>" instead of "<code>&gt;= 5</code>". This was a bug. It's possible
for a player to get more than 5 pieces in a row, if the player plays a piece in
an empty square that joins two shorter rows of pieces together.</p>

<break/>

<np><b><u>Marking the Winning Pieces</u></b></np>

<p>In my program, when a player wins, the row of pieces that wins the game is
marked with a red line. To do this, I added four instance variables of type
<ptype>int</ptype> to the <swing><classname>Board</classname></swing><fx><classname>GoMokuBoard</classname></fx> class.
 The instance variables are
named <code>win_r1</code>, <code>win_c1</code>, <code>win_r2</code>, and <code>win_c2</code>.
After a player has won the game, the values of these
variables have been set to mark the squares at the two ends of the winning row of
pieces. The positions of these squares are given by <code>(win_r1,win_c1)</code>
and <code>(win_r2,win_c2)</code>.</p>

<p>I added some code to the  <code>count()</code> method to
set the values of these variables. As the <code>count()</code> method
counts the pieces in a line, it sets <code>win_r1</code>, <code>win_c1</code>,
<code>win_r2</code>, and <code>win_c2</code> to mark the location of the last piece it
finds in the two directions it checks.  The values are always set when <code>count()</code>
is called.  If the game is won, this will set the
values correctly.   My program depends on the fact that once it has been determined
that a game has been won, <code>count()</code> will not be called again during that
game.  This means that when the red line is drawn, the variables
<code>win_r1</code>, <code>win_c1</code>, <code>win_r2</code>, and <code>win_c2</code>
will still mark the ends of the line of pieces that won the game.
(I'm not really happy about how tricky this is.  My solution is "fragile" in the sense
that it could easily be broken inadvertently if the logic of the program is changed
just a little.  But I really wanted to mark the winning pieces&dots;)</p>
</exercise-discuss>
<exercise-code>
<pre><prog name="GoMoku" scope="fx">

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.stage.Stage;
import javafx.scene.layout.Pane;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.scene.input.MouseEvent;

/**
 * This panel lets two users play Go Moku against each other.
 * Black always starts the game.
 */
public class GoMoku extends Application {

    public static void main(String[] args) {
        launch(args);
    }
    
    //---------------------------------------------------------------------
    
    private static final int  // Constants to represent possible contents 
             EMPTY = 0,       //     of squares on the board.  The constants
             BLACK = 1,       //     BLACK and WHITE are also used to
             WHITE = 2;       //     represent the current player.
    
    private GoMokuBoard board; // A canvas on which a checker board is drawn,
                         // defined by a static nested subclass.  Much of
                         // the game logic is defined in this class.


    private Button newGameButton;  // Button for starting a new game.
    
    private Button resignButton;   // Button that a player can use to end 
                                    // the game by resigning.

    private Label message;  // Label for displaying messages to the user.

    /**
     * The constructor creates the Board (which in turn creates and manages
     * the buttons and message label), adds all the components, and sets
     * the bounds of the components.  A null layout is used.  (This is
     * the only thing that is done in the main Checkers class.)
     */
    public void start(Stage stage) {

        /* Create the label that will show messages. */
        
        message = new Label("Click \"New Game\" to begin.");
        message.setTextFill( Color.rgb(100,255,100) ); // Light green.
        message.setFont( Font.font(null, FontWeight.BOLD, 18) );
        
        /* Create the buttons and the board.  The buttons MUST be
         * created first, since they are used in the CheckerBoard
         * constructor! */

        newGameButton = new Button("New Game");
        resignButton = new Button("Resign");

        board = new GoMokuBoard(); // a subclass of Canvas, defined below
        board.drawBoard();  // draws the empty board
        
        /* Set up ActionEvent handlers for the buttons and a MousePressed handler
         * for the board.  The handlers call instance methods in the board object. */

        newGameButton.setOnAction( e -> board.doNewGame() );
        resignButton.setOnAction( e -> board.doResign() );
        board.setOnMousePressed( e -> board.mousePressed(e) );

        /* Set the location of each child by calling its relocate() method */

        board.relocate(20,20);
        newGameButton.relocate(370, 120);
        resignButton.relocate(370, 200);
        message.relocate(20, 370);
        
        /* Set the sizes of the buttons.  For this to have an effect, make
         * the butons "unmanaged."  If they are managed, the Pane will set
         * their sizes. */
        
        resignButton.setManaged(false);
        resignButton.resize(100,30);
        newGameButton.setManaged(false);
        newGameButton.resize(100,30);
        
        /* Create the Pane and give it a preferred size.   If the
         * preferred size were not set, the unmanaged buttons would 
         * not be included in the Pane's computed preferred size. */
        
        Pane root = new Pane();
        
        root.setPrefWidth(500);
        root.setPrefHeight(420);
        
        /* Add the child nodes to the Pane and set up the rest of the GUI */

        root.getChildren().addAll(board, newGameButton, resignButton, message);
        root.setStyle("-fx-background-color: darkgreen; "
                           + "-fx-border-color: darkred; -fx-border-width:3");
        Scene scene = new Scene(root);
        stage.setScene(scene);
        stage.setResizable(false);
        stage.setTitle("Go Moku!");
        stage.show();

    } // end start()


    /**
     * This canvas displays a GoMoku board: a 314-by-314 board divided into 13
     * rows and 13 columns of squares. This class contains methods that are
     * called in response to a mouse click on the canvas and in response to 
     * clicks on the New Game and Resign buttons.   Note that the "New Game" 
     * and "Resign" buttons must be created before the Board constructor is 
     * called, since the constructor references the buttons (in the call 
     * to doNewGame()).
     */
    private class GoMokuBoard extends Canvas {
        
        int[][] boardData;

        boolean gameInProgress; // Is a game currently in progress?

        /* The next three variables are valid only when the game is in progress. */

        int currentPlayer;      // Whose turn is it now?  The possible values
                                //    are BLACK and WHITE

        int win_r1, win_c1, win_r2, win_c2; // When a player wins by getting five or more
                                            // pieces in a row, the squares at the
                                            // ends of the row are (win_r1,win_c1)
                                            // and (win_r2,win_c2).  A red line is
                                            // drawn between these squares.  The values are 
                                            // set in the count() method.  The are only used
                                            // in drawWinLine(), which is only called after
                                            // the game has been won.
        
        
        /**
         * Constructor.  Creates a CheckersData to represent the
         * contents of the checkerboard, and calls doNewGame to 
         * start the first game.
         */
        GoMokuBoard() {
            super(314,314);  // canvas is 314-by-314 pixels
            doNewGame();
        }

        /**
         * Start a new game.  This method is called when the Board is first
         * created and when the "New Game" button is clicked.  Event handling
         * is set up in the start() method in the main class.
         */
        void doNewGame() {
            if (gameInProgress == true) {
                    // This should not be possible, but it doesn't hurt to check.
                message.setText("Finish the current game first!");
                return;
            }
            boardData = new int[13][13];   // Start the game with an empty board.
                                       //  This relies on the fact that EMPTY = 0.
            currentPlayer = BLACK;   // BLACK moves first.
            message.setText("Black:  Make your move.");
            gameInProgress = true;
            newGameButton.setDisable(true);
            resignButton.setDisable(false);
            drawBoard();
        }

        /**
         * Current player resigns.  Game ends.  Opponent wins.  This method is
         * called when the user clicks the "Resign" button.  Event handling is
         * set up in the start() method in the main class.
         */
        void doResign() {
            if (gameInProgress == false) {  // Should be impossible.
                message.setText("There is no game in progress!");
                return;
            }
            if (currentPlayer == WHITE)
                gameOver("WHITE resigns.  BLACK wins.");
            else
                gameOver("BLACK resigns.  WHITE wins.");
        }

        /**
         * The game ends.  The parameter, str, is displayed as a message
         * to the user.  The states of the buttons are adjusted so players
         * can start a new game.  This method is called when the game
         * ends at any point in this class.
         */
        void gameOver(String str) {
            message.setText(str);
            newGameButton.setDisable(false);
            resignButton.setDisable(true);
            gameInProgress = false;
        }


        /**
         * This is called by mousePressed() when a player clicks on the
         * square in the specified row and col.  It has already been checked
         * that a game is, in fact, in progress.
         */
        void doClickSquare(int row, int col) {

            /* Check that the user clicked an empty square.  If not, show an
              error message and exit. */

            if ( boardData[row][col] != EMPTY ) {
                if (currentPlayer == BLACK)
                    message.setText("BLACK:  Please click an empty square.");
                else
                    message.setText("WHITE:  Please click an empty square.");
                return;
            }

            /* Make the move.  Check if the board is full or if the move
              is a winning move.  If so, the game ends.  If not, then it's
              the other user's turn.  If there is a winner, call
              drawWinLine() to mark the winning pieces. */

            boardData[row][col] = currentPlayer;  // Make the move.
            drawBoard();

            if (winner(row,col)) {  // First, check for a winner.
                if (currentPlayer == WHITE)
                    gameOver("WHITE wins the game!");
                else
                    gameOver("BLACK wins the game!");
                drawWinLine();
                return;
            }

            boolean emptySpace = false;     // Check if the board is full.
            for (int i = 0; i &lt; 13; i++)
                for (int j = 0; j &lt; 13; j++)
                    if (boardData[i][j] == EMPTY)
                        emptySpace = true;
            if (emptySpace == false) {
                gameOver("The game ends in a draw.");
                return;
            }

            /* Continue the game.  It's the other player's turn. */

            if (currentPlayer == BLACK) {
                currentPlayer = WHITE;
                message.setText("WHITE:  Make your move.");
            }
            else {  
                currentPlayer = BLACK;
                message.setText("BLACK:  Make your move.");
            }

        }  // end doClickSquare()


        /**
         * This is called just after a piece has been played on the
         * square in the specified row and column.  It determines
         * whether that was a winning move by counting the number
         * of squares in a line in each of the four possible
         * directions from (row,col).  If there are 5 squares (or more)
         * in a row in any direction, then the game is won.  The values
         * of the variables win_r1, win_c1, win_r2, win_c2 are set in
         * any case, but they are only valid -- and will only be used --
         * if the game has actually been won.
         */
        private boolean winner(int row, int col) {

            if (count( boardData[row][col], row, col, 1, 0 ) >= 5)
                return true;
            if (count( boardData[row][col], row, col, 0, 1 ) >= 5)
                return true;
            if (count( boardData[row][col], row, col, 1, -1 ) >= 5)
                return true;
            if (count( boardData[row][col], row, col, 1, 1 ) >= 5)
                return true;

            /* When we get to this point, we know that the game is not won.*/
            
            return false;

        }  // end winner()


        /**
         * Counts the number of the specified player's pieces starting at
         * square (row,col) and extending along the direction specified by
         * (dirX,dirY).  It is assumed that the player has a piece at
         * (row,col).  This method looks at the squares (row + dirX, col + dirY),
         * (row + 2*dirX, col + 2*dirY), ... until it hits a square that is
         * off the board or is not occupied by one of the player's pieces.
         * It counts the squares that are occupied by the player's pieces.
         * Furthermore, it sets (win_r1,win_c1) to mark last position where
         * it saw one of the player's pieces.  Then, it looks in the
         * opposite direction, at squares (row - dirX, col-dirY),
         * (row - 2*dirX, col - 2*dirY), ... and does the same thing.
         * Except, this time it sets (win_r2,win_c2) to mark the last piece.
         * Note:  The values of dirX and dirY must be 0, 1, or -1.  At least
         * one of them must be non-zero.
         */
        private int count(int player, int row, int col, int dirX, int dirY) {

            int ct = 1;  // Number of pieces in a row belonging to the player.

            int r, c;    // A row and column to be examined

            r = row + dirX;  // Look at square in specified direction.
            c = col + dirY;
            while ( r >= 0 &amp;&amp; r &lt; 13 &amp;&amp; c >= 0 &amp;&amp; c &lt; 13 &amp;&amp; boardData[r][c] == player ) {
                // Square is on the board and contains one of the players's pieces.
                ct++;
                r += dirX;  // Go on to next square in this direction.
                c += dirY;
            }

            win_r1 = r - dirX;  // The next-to-last square looked at.
            win_c1 = c - dirY;  //    (The LAST one looked at was off the board or
            //    did not contain one of the player's pieces.

            r = row - dirX;  // Look in the opposite direction.
            c = col - dirY;
            while ( r >= 0 &amp;&amp; r &lt; 13 &amp;&amp; c >= 0 &amp;&amp; c &lt; 13 &amp;&amp; boardData[r][c] == player ) {
                // Square is on the board and contains one of the players's pieces.
                ct++;
                r -= dirX;   // Go on to next square in this direction.
                c -= dirY;
            }

            win_r2 = r + dirX;
            win_c2 = c + dirY;

            // At this point, (win_r1,win_c1) and (win_r2,win_c2) mark the endpoints
            // of the line of pieces belonging to the player.

            return ct;

        }  // end count()


        /**
         * Draws the board and the pieces on the board.  This method does NOT
         * draw the red line through the winning pieces after the game has
         * been won.
         */
        public void drawBoard() {

            GraphicsContext g = getGraphicsContext2D();
            g.setFill( Color.LIGHTGRAY );  // fill canvas with light gray
            g.fillRect(0,0,314,314);

            /* Draw lines separating the square and along the edges of the canvas.  */

            g.setStroke(Color.BLACK);
            g.setLineWidth(2);
            for (int i = 0; i &lt;= 13; i++) {
                g.strokeLine(1 + 24*i, 0, 1 + 24*i, 314);
                g.strokeLine(0, 1 + 24*i, 314, 1 + 24*i);
            }

            /* Draw the pieces that are on the board. */

            for (int row = 0; row &lt; 13; row++)
                for (int col = 0; col &lt; 13; col++)
                    if (boardData[row][col] != EMPTY)
                        drawPiece(g, boardData[row][col], row, col);

        }  // end drawBoard()


        /**
         * Draw a piece in the square at (row,col).  The color is specified
         * by the piece parameter, which should be either BLACK or WHITE.
         */
        private void drawPiece(GraphicsContext g, int piece, int row, int col) {
            if (piece == WHITE) {
                g.setFill(Color.WHITE);
                g.fillOval(4 + 24*col, 4 + 24*row, 18, 18);
                g.setStroke(Color.BLACK);
                g.setLineWidth(1);
                g.strokeOval(4 + 24*col, 4 + 24*row, 18, 18);
            }
            else {
                g.setFill(Color.BLACK);
                g.fillOval(4 + 24*col, 4 + 24*row, 18, 18);
            }
        }


        /**
         * Draw a 4-pixel wide red line from the middle of the square at
         * (win_r1,win_c1) to the middle of the square at (win_r2,win_c2).
         * The values of the variables are set in the count() method.
         * This routine is called to mark the pieces that won the game.
         * It can only be called once in a given game, at the point where
         * the game ends because a user places a winning piece.
         */
        private void drawWinLine() {
            GraphicsContext g = getGraphicsContext2D();
            g.setStroke(Color.RED);
            g.setLineWidth(4);
            g.strokeLine( 13 + 24*win_c1, 13 + 24*win_r1, 13 + 24*win_c2, 13 + 24*win_r2 );
        }


        /**
         * Respond to a user click on the board.  If no game is
         * in progress, show an error message.  Otherwise, find
         * the row and column that the user clicked and call
         * doClickSquare() to handle it.
         */
        public void mousePressed(MouseEvent evt) {
            if (gameInProgress == false)
                message.setText("Click \"New Game\" to start a new game.");
            else {
                int col = (int)((evt.getX() - 2) / 24);
                int row = (int)((evt.getY() - 2) / 24);
                if (col >= 0 &amp;&amp; col &lt; 13 &amp;&amp; row >= 0 &amp;&amp; row &lt; 13)
                    doClickSquare(row,col);
            }
        }

    }  // end nested class GoMokuBoard


} // end class GoMoku
</prog></pre>
<pre><prog name="GoMoku" scope="swing">
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;    

/**
 * This program lets two users play Go Moku (a.k.a Pente) against each 
 * other.  Black always starts the game.  When a player gets five-in-a-row,
 * that player wins.  The game ends in a draw if the board is filled
 * before either player wins.
 *
 * The class has a main() routine that lets it be run as a stand-alone
 * application.  The application just opens a window that uses an object
 * of type GoMoku as its content pane.
 * 
 */

public class GoMoku extends JPanel {

    /**
     * Main routine makes it possible to run GoMoku as a stand-alone
     * application.  Opens a window showing a GoMoku panel; the program
     * ends when the user closes the window.
     */
    public static void main(String[] args) {
        JFrame window = new JFrame("GoMoku");
        GoMoku content = new GoMoku();
        window.setContentPane(content);
        window.pack();
        Dimension screensize = Toolkit.getDefaultToolkit().getScreenSize();
        window.setLocation( (screensize.width - window.getWidth())/2,
                                  (screensize.height - window.getHeight())/2 );
        window.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
        window.setResizable(false);  
        window.setVisible(true);
    }


    private JButton newGameButton;  // Button for starting a new game.

    private JButton resignButton;   // Button that a player can use to end the 
                                    //   game by resigning.

    private JLabel message;  // Label for displaying messages to the user.


    /**
     *  The constructor lays out the panel.  The work of
     *  the game is all done in the Board object.  A null layout
     *  is used, and all setup of sizes and positions is done here.
     */
    public GoMoku() {

        setLayout(null);  // I will do the layout myself.

        setPreferredSize( new Dimension(500,420) );

        setBackground(new Color(0,100,0));  // Dark green background.

        /* Create the components and add them to the panel. */

        Board board = new Board();  // Note: The constructor for the
                                    //   board also creates the buttons
                                    //   and label.
        add(board);
        add(newGameButton);
        add(resignButton);
        add(message);

        /* Set the position and size of each component by calling
           its setBounds() method. */

        board.setBounds(20,20,314,314); // Note:  size MUST be 314-by-314 !
        newGameButton.setBounds(370, 120, 120, 30);
        resignButton.setBounds(370, 200, 120, 30);
        message.setBounds(20, 370, 460, 30);
    }


    // ----------------------- Nested class -----------------------------------

    /**
     * This panel displays a 310-by-310 pixel checkerboard pattern with
     * a 2-pixel black border.  It is assumed that the size of the
     * pannel is set to exactly 314-by-314 pixels.  This class does
     * the work of letting the users play Go Moku, and it displays
     * the board.  In this program, the board has 13 rows and
     * columns of squares.
     */
    class Board extends JPanel implements  MouseListener {

        int[][] board;   // The data for the board is kept here.  The values
                         //   in this array are chosen from the following constants.

        static final int EMPTY = 0,       // Represents an empty square.
                WHITE = 1,       // A white piece.
                BLACK = 2;       // A black piece.

        boolean gameInProgress; // Is a game currently in progress?

        int currentPlayer;      // Whose turn is it now?  The possible values
                                //    are WHITE and BLACK.  (This is valid only while
                                //    a game is in progress.)

        int win_r1, win_c1, win_r2, win_c2; // When a player wins by getting five or more
                                            // pieces in a row, the squares at the
                                            // ends of the row are (win_r1,win_c1)
                                            // and (win_r2,win_c2).  A red line is
                                            // drawn between these squares.  When there
                                            // are not five pieces in a row, the value of
                                            // win_r1 is -1.  The values are set in the
                                            // count() method.  The value of win_r1 is
                                            // tested in the paintComponent() method.

        /**
         * Constructor.  Create the buttons and label.  Listen for mouse
         * clicks and for clicks on the buttons.  Create the board and
         * start the first game.
         */
        public Board() {
            setBackground(Color.LIGHT_GRAY);
            addMouseListener(this);
            resignButton = new JButton("Resign");
            resignButton.addActionListener( e -&gt; doResign() );
            newGameButton = new JButton("New Game");
            newGameButton.addActionListener( e -&gt; doNewGame());
            message = new JLabel("",JLabel.CENTER);
            message.setFont(new  Font("Serif", Font.BOLD, 20));
            message.setForeground(Color.GREEN);
            board = new int[13][13];
            doNewGame();
        }


        /**
         * Begin a new game; this is called by the actionPerformed()
         * method when a user clicks the New Game button.
         */
        void doNewGame() {
            if (gameInProgress == true) {
                // This should not be possible because New Game button
                // is enabled only when it is legal to use it, but it doesn't 
                // hurt to check.
                message.setText("Finish the current game first!");
                return;
            }
            for (int row = 0; row &lt; 13; row++)       // Fill the board with EMPTYs
                for (int col = 0; col &lt; 13; col++)
                    board[row][col] = EMPTY;
            currentPlayer = BLACK;   // BLACK moves first.
            message.setText("BLACK:  Make your move.");
            gameInProgress = true;
            newGameButton.setEnabled(false);
            resignButton.setEnabled(true);
            win_r1 = -1;  // This value indicates that no red line is to be drawn.
            repaint();
        }


        /**
         * Current player resigns; this is called by the actionPerformed()
         * method when a user clicks the Resign button.  Game ends, and
         * opponent wins.
         */
        void doResign() {
            if (gameInProgress == false) {
                // This should not be possible.
                message.setText("There is no game in progress!");
                return;
            }
            if (currentPlayer == WHITE)
                message.setText("WHITE resigns.  BLACK wins.");
            else
                message.setText("BLACK resigns.  WHITE wins.");
            newGameButton.setEnabled(true);
            resignButton.setEnabled(false);
            gameInProgress = false;
        }


        /**
         * This method is called whenever the game ends.  The parameter, str,
         * is displayed as a message, and the buttons are enabled/disabled
         * to reflect the fact that a game is not currently in progress.
         */
        void gameOver(String str) {
            message.setText(str);
            newGameButton.setEnabled(true);
            resignButton.setEnabled(false);
            gameInProgress = false;
        }


        /**
         * This is called by mousePressed() when a player clicks on the
         * square in the specified row and col.  It has already been checked
         * that a game is, in fact, in progress.
         */
        void doClickSquare(int row, int col) {

            /* Check that the user clicked an empty square.  If not, show an
                error message and exit. */

            if ( board[row][col] != EMPTY ) {
                if (currentPlayer == BLACK)
                    message.setText("BLACK:  Please click an empty square.");
                else
                    message.setText("WHITE:  Please click an empty square.");
                return;
            }

            /* Make the move.  Check if the board is full or if the move
               is a winning move.  If so, the game ends.  If not, then it's
               the other user's turn. */

            board[row][col] = currentPlayer;  // Make the move.
            repaint();

            if (winner(row,col)) {  // First, check for a winner.
                if (currentPlayer == WHITE)
                    gameOver("WHITE wins the game!");
                else
                    gameOver("BLACK wins the game!");
                return;
            }

            boolean emptySpace = false;     // Check if the board is full.
            for (int i = 0; i &lt; 13; i++)
                for (int j = 0; j &lt; 13; j++)
                    if (board[i][j] == EMPTY)
                        emptySpace = true;
            if (emptySpace == false) {
                gameOver("The game ends in a draw.");
                return;
            }

            /* Continue the game.  It's the other player's turn. */

            if (currentPlayer == BLACK) {
                currentPlayer = WHITE;
                message.setText("WHITE:  Make your move.");
            }
            else {  
                currentPlayer = BLACK;
                message.setText("BLACK:  Make your move.");
            }

        }  // end doClickSquare()


        /**
         * This is called just after a piece has been played on the
         * square in the specified row and column.  It determines
         * whether that was a winning move by counting the number
         * of squares in a line in each of the four possible
         * directions from (row,col).  If there are 5 squares (or more)
         * in a row in any direction, then the game is won.
         */
        private boolean winner(int row, int col) {

            if (count( board[row][col], row, col, 1, 0 ) &gt;= 5)
                return true;
            if (count( board[row][col], row, col, 0, 1 ) &gt;= 5)
                return true;
            if (count( board[row][col], row, col, 1, -1 ) &gt;= 5)
                return true;
            if (count( board[row][col], row, col, 1, 1 ) &gt;= 5)
                return true;

            /* When we get to this point, we know that the game is not
               won.  The value of win_r1, which was changed in the count()
               method, has to be reset to -1, to avoid drawing a red line
               on the board. */

            win_r1 = -1;
            return false;

        }  // end winner()


        /**
         * Counts the number of the specified player's pieces starting at
         * square (row,col) and extending along the direction specified by
         * (dirX,dirY).  It is assumed that the player has a piece at
         * (row,col).  This method looks at the squares (row + dirX, col + dirY),
         * (row + 2*dirX, col + 2*dirY), ... until it hits a square that is
         * off the board or is not occupied by one of the player's pieces.
         * It counts the squares that are occupied by the player's pieces.
         * Furthermore, it sets (win_r1,win_c1) to mark last position where
         * it saw one of the player's pieces.  Then, it looks in the
         * opposite direction, at squares (row - dirX, col-dirY),
         * (row - 2*dirX, col - 2*dirY), ... and does the same thing.
         * Except, this time it sets (win_r2,win_c2) to mark the last piece.
         * Note:  The values of dirX and dirY must be 0, 1, or -1.  At least
         * one of them must be non-zero.
         */
        private int count(int player, int row, int col, int dirX, int dirY) {

            int ct = 1;  // Number of pieces in a row belonging to the player.

            int r, c;    // A row and column to be examined

            r = row + dirX;  // Look at square in specified direction.
            c = col + dirY;
            while ( r &gt;= 0 &amp;&amp; r &lt; 13 &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; 13 &amp;&amp; board[r][c] == player ) {
                // Square is on the board and contains one of the players's pieces.
                ct++;
                r += dirX;  // Go on to next square in this direction.
                c += dirY;
            }

            win_r1 = r - dirX;  // The next-to-last square looked at.
            win_c1 = c - dirY;  //    (The LAST one looked at was off the board or
            //    did not contain one of the player's pieces.

            r = row - dirX;  // Look in the opposite direction.
            c = col - dirY;
            while ( r &gt;= 0 &amp;&amp; r &lt; 13 &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; 13 &amp;&amp; board[r][c] == player ) {
                // Square is on the board and contains one of the players's pieces.
                ct++;
                r -= dirX;   // Go on to next square in this direction.
                c -= dirY;
            }

            win_r2 = r + dirX;
            win_c2 = c + dirY;

            // At this point, (win_r1,win_c1) and (win_r2,win_c2) mark the endpoints
            // of the line of pieces belonging to the player.

            return ct;

        }  // end count()


        /**
         * Draws the board and the pieces on the board.  If the game has
         * been won by getting five or more pieces in a row, draws a red line
         * through the pieces.
         */
        public void paintComponent(Graphics g) {

            super.paintComponent(g); // Fill with background color, lightGray
            ((Graphics2D)g).setStroke(new BasicStroke(2));

            /* Draw a two-pixel black border around the edges of the canvas,
               and draw grid lines in darkGray.  */

            g.setColor(Color.BLACK);
            for (int i = 0; i &lt;= 13; i++) {
                g.drawLine(1 + 24*i, 0, 1 + 24*i, 314);
                g.drawLine(0, 1 + 24*i, 314, 1 + 24*i);
            }

            /* Draw the pieces that are on the board, with anti-aliasing turned on. */

            ((Graphics2D)g).setRenderingHint(RenderingHints.KEY_ANTIALIASING, 
                                                RenderingHints.VALUE_ANTIALIAS_ON);
                                                
            for (int row = 0; row &lt; 13; row++)
                for (int col = 0; col &lt; 13; col++)
                    if (board[row][col] != EMPTY)
                        drawPiece(g, board[row][col], row, col);

            /* If the game has been won, then win_r1 &gt;= 0.  Draw a line to mark
               the five (or more) winning pieces. */

            if (win_r1 &gt;= 0)
                drawWinLine(g);

        }  // end paintComponent()


        /**
         * Draw a piece in the square at (row,col).  The color is specified
         * by the piece parameter, which should be either BLACK or WHITE.
         */
        private void drawPiece(Graphics g, int piece, int row, int col) {
            if (piece == WHITE)
                g.setColor(Color.WHITE);
            else
                g.setColor(Color.BLACK);
            g.fillOval(4 + 24*col, 4 + 24*row, 19, 19);
        }


        /**
         * Draw a 2-pixel wide red line from the middle of the square at
         * (win_r1,win_c1) to the middle of the square at (win_r2,win_c2).
         * This routine is called to mark the pieces that won the game.
         * The values of the variables are set in the count() method.
         */
        private void drawWinLine(Graphics g) {
            g.setColor(Color.RED);
            ((Graphics2D)g).setStroke(new BasicStroke(4));
            g.drawLine( 13 + 24*win_c1, 13 + 24*win_r1, 13 + 24*win_c2, 13 + 24*win_r2 );
        }


        /**
         * Respond to a user click on the board.  If no game is
         * in progress, show an error message.  Otherwise, find
         * the row and column that the user clicked and call
         * doClickSquare() to handle it.
         */
        public void mousePressed(MouseEvent evt) {
            if (gameInProgress == false)
                message.setText("Click \"New Game\" to start a new game.");
            else {
                int col = (evt.getX() - 2) / 24;
                int row = (evt.getY() - 2) / 24;
                if (col &gt;= 0 &amp;&amp; col &lt; 24 &amp;&amp; row &gt;= 0 &amp;&amp; row &lt; 24)
                    doClickSquare(row,col);
            }
        }


        public void mouseReleased(MouseEvent evt) { }
        public void mouseClicked(MouseEvent evt) { }
        public void mouseEntered(MouseEvent evt) { }
        public void mouseExited(MouseEvent evt) { }

    }  // end nested class Board


} // end class GoMoku
</prog></pre>
</exercise-code>
</exercise>
   
   

</exercises>