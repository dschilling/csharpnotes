<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE exercises SYSTEM "../csharpnotes1.dtd" >

<exercises>

<exercise>
<exercise-question><p>The folder <sourceref href="nature-images"/> contains several pictures of
animals.  (In the web site download, you can find that folder in the <code>chapter13</code> directory
inside the <code>source</code> directory.)
Write a "scratch off" program that could be used by a small child that works as follows:
The program window starts by showing a large uniformly colored rectangle, with one of the
animal pictures hidden behind it.  As the user drags the mouse over the image, part of the
colored overlay is scratched off, revealing the picture underneath.  Here is what it should
look like after part of the overlay has been removed:</p>
<img src="scratch-off.jpg" width="450" height="322" tex="scratch-off.eps" texscale="0.6" alt="a partly revealed bluebird"/>
<np>You can implement this by using one canvas, containing the colored overlay, stacked on top of another
canvas that contains the animal picture.  (Stacked canvases were used in the sample
program <sourceref href="ToolPaint.java"/> from <localref href="GUI2.2.4"/>.)
To implement scratching off part of the overlay, just clear a small rect in the overlay 
canvas around the mouse location.  The program should have some way to move on to the next
picture.  Another idea is to have several different sizes of scratchers, so that an
impatient child can use a giant one that will remove large swatches of color.</np>
</exercise-question>
<exercise-discuss><p>The pictures have to be read into the program as objects of type
<classname>Image</classname>.  I store the pictures into an <atype>ArrayList&lt;Image&gt;</atype>, <code>pictures</code>.
I shuffle them into a random order using the standard function <code>Collections.shuffle()</code>,
so that the pictures will be used in a different order each time the program is run.
An instance variable, <code>nextPicIndex</code>, is used to keep track of which picture is
going to be shown next.</p>

<p>The basic stacked canvas idea is easy to implement.  The two canvases are
placed into a <classname>StackPane</classname>.  An animal picture is drawn in the bottom 
canvas.  The animal pictures are not all the same size, so I picked an arbitrary canvas
size of 800-by-600 and stretched the pictures to fit the canvas, using a <code>drawImage()</code>
method that includes the width and height of the rectangle into which the image is drawn.  At
the same time, I fill the overlay canvas with a random color:</p>

<pre>overlayGraphics.setFill( Color.hsb(360*Math.random(), 0.5, 0.5) );
overlayGraphics.fillRect( 0,0, width,height );
picGraphics.drawImage( pictures.get(nextPicIndex), 0,0, width,height );</pre>

<p>I added some controls at the bottom of the program window: a button that loads the next
picture, a <classname>ComboBox</classname> for selecting the size of the "scratcher,"
and (for the really impatient), a button that will clear the entire overlay canvas.</p>
</exercise-discuss>
<exercise-code>
<pre><prog name="ScratchOff">
import javafx.application.Application;
import javafx.stage.Stage;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ComboBox;
import javafx.scene.layout.HBox;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.StackPane;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.paint.Color;
import javafx.scene.image.Image;
import javafx.scene.input.MouseEvent;
import javafx.geometry.Pos;
import javafx.geometry.Insets;

import java.util.ArrayList;
import java.util.Collections;


/**
 * A program that lets the user "scratch off" a mask that is covering an
 * image, by dragging the mouse.  This program requires that some specific
 * image files be available as resource files in a folder named "nature-images".
 */
public class ScratchOff extends Application {

    public static void main(String[] args) {
        launch();
    }
    //-------------------------------------------------------------------
    
    private final static String[] picFileNames = {
                // These are the names of the resource image files that contain
                // the pictures used by this program.  The must be in folder
                // named nature-images.
            "bluejay.jpg", "chipmunk.jpg", "collie.jpg", "elephants.jpg", 
            "faun.jpg", "lion.jpg", "polar-bear.jpg", "stork.jpg"
    };
    
    private Canvas picCanvas;                // canvas where picture is drawn
    private GraphicsContext picGraphics;     // graphics context for picCanvas
    private Canvas overlayCanvas;            // canvas that hides the picture
    private GraphicsContext overlayGraphics; // graphics context for overlayCanvas
    
    private ArrayList&lt;Image> pictures;  // An arraylist containing the images
    private int nextPicIndex;  // The index of the array list of the next picture
                               // that will be drawn.  To avoid repeating a picture
                               // until all of the pictures have been used,
                               // the array list is shuffled and the pictures are
                               // shown in the reverse order that they occur in the
                               // list.  If all the pictures are used, the list is
                               // reshuffled and the pictures are reused.
    
    private final int[] sizes = { 10, 20, 35, 60 };  // sizes for the square that
                                                     // is revealed when the user
                                                     // drags the mouse
    private double scratcherSize; // current size of the rectangle; one of the
                                  // items from the previous array, depeding on
                                  // the current setting of a ComboBox
    
    private final static int width = 800;    // canvas size
    private final static int height = 600;
    
    /**
     * Set up the GUI.  The overlay canvas, which hides the picture is
     * stacked on top of the canvas that displays the image.  There are
     * some buttons and a combo box at the bottom of the window.
     */
    public void start(Stage stage) {
                
        picCanvas = new Canvas(width,height);
        picGraphics = picCanvas.getGraphicsContext2D();
        overlayCanvas = new Canvas(width,height);
        overlayGraphics = overlayCanvas.getGraphicsContext2D();
        
        pictures = new ArrayList&lt;Image>();
        for (int i = 0; i &lt; picFileNames.length; i++) {
            pictures.add( new Image("nature-images/" + picFileNames[i]) );
        }
        Collections.shuffle(pictures);  // put pictures in a random order
        nextPicIndex = picFileNames.length - 1;  // index for the first picture
        newPic();  // Set up the first picture.
        
        overlayCanvas.setOnMousePressed( this::scratch );
        overlayCanvas.setOnMouseDragged( this::scratch );
        
        StackPane canvasHolder = new StackPane(picCanvas,overlayCanvas);
        canvasHolder.setStyle("-fx-border-color: #444; -fx-border-width:5px");
        
        Button newPicBtn = new Button("New ScratchOff!");
        newPicBtn.setOnAction( e -> newPic() );
        Button showAllBtn = new Button("Show the Whole Picture!");
        showAllBtn.setOnAction( e -> overlayGraphics.clearRect(0,0,width,height) );
        
        ComboBox&lt;String> sizeSelect = new ComboBox&lt;>();
        sizeSelect.getItems().addAll("Small", "Normal", "Big", "Giant");
        sizeSelect.getSelectionModel().select(1);
        scratcherSize = sizes[1];
        sizeSelect.setOnAction( 
                e -> scratcherSize = sizes[ sizeSelect.getSelectionModel().getSelectedIndex() ] );
        
        HBox bottom = new HBox(10,newPicBtn,showAllBtn,    new Label("  Scratcher Size:"), sizeSelect);
        bottom.setAlignment(Pos.CENTER);
        bottom.setPadding( new Insets(10) );
        
        BorderPane root = new BorderPane(canvasHolder);
        root.setBottom(bottom);
        
        stage.setScene( new Scene(root) );
        stage.setResizable(false);
        stage.setTitle("Scratc Off to Reveal a Picture!");
        stage.show();
        
    }
    
    /**
     * Show the next picture in the picCanvas, and fill the overlay canvas
     * with a random dull color to hide the picture.  Set up nextPicIndex
     * for the next picture.
     */
    private void newPic() {
        overlayGraphics.setFill( Color.hsb(360*Math.random(), 0.5, 0.5) );
        overlayGraphics.fillRect(0,0,width,height);
        picGraphics.drawImage(pictures.get(nextPicIndex),0,0,width,height);
        if (nextPicIndex == 0) {
            Image item0 = pictures.get(0);
            do { // Avoid having the item that is showing now be put
                 // at the end of the list where it will be shown next.
                Collections.shuffle(pictures);
            } while (pictures.get(pictures.size()-1) == item0);
            nextPicIndex = pictures.size() - 1;
        }
        else {
            nextPicIndex--;
        }
    }
    
    /**
     * When the user pressed or drags the mouse, clear a rect in the
     * overlay canvas, with a size given by scratcherSize.
     */
    private void scratch(MouseEvent evt) {
        overlayGraphics.clearRect( evt.getX() - scratcherSize/2, 
                evt.getY() - scratcherSize/2, scratcherSize, scratcherSize );
    }
    
} // end ScratchOff
</prog></pre>
</exercise-code>
</exercise>


<exercise>
<exercise-question><p>The <classname>StopWatchLabel</classname>
component from <localref href="GUI2.3.1"/> displays the text "Timing&dots;"
when the stopwatch is running. It would be nice if it displayed the elapsed
time since the stopwatch was started. For that, you need to create an
<classname>AnimationTimer</classname>. (See <localref href="GUI1.3.5"/>.)
Add an <classname>AnimationTimer</classname> to the original source code, 
<sourceref href="StopWatchLabel.java"/>, to drive the display of the elapsed time in
seconds.</p>
</exercise-question>
<exercise-discuss><p>This one is really too easy!  As suggested, I added an
<classname>AnimationTimer</classname>, named <code>timer</code>, as an
instance variable.  (I also changed some of the occurrences of the word "timer"
in the original program to "stopwatch" to try to avoid some confusion:
the stopwatch is a kind of timer, and we are using another kind of timer to
implement it.)  When the stopwatch starts running, it is necessary to call
<code>timer.start()</code> to start the animation timer running, and when the
stopwatch stops running, <code>timer.stop() must be called.</code>
The only other thing that is needed is to create the <classname>AnimationTimer</classname>
object. Since <classname>AnimationTimer</classname> is an abstract class,
we need a subclass, and we need to provide a definition for the abstract method
<code>handle()</code>.  That method, which will be called many times per second,
can update the label to show the elapsed time.  Using an anonymous class,</p>

<pre>timer = new AnimationTimer() {
    public void handle(long now) {
        long elapsedTime = System.currentTimeMillis() - startTime;
        String text = String.format(
                 "%3.1f seconds elapsed", elapsedTime/1000.0);
        setText(text);
    }
};</pre>

<np>In the program, I don't create the animation timer until the first time
the stopwatch is started.  Note that when the stopwatch is stopped, the program
displays the time with three digits after the decimal point.  While it's running,
it doesn't make sense to be that accurate since the display won't be updated 
every millisecond.  So, I only use one digit after the 
decimal point when the stopwatch is running.</np>
</exercise-discuss>
<exercise-code>
<np><b>The timer component, with changes from the original shown in &newcodestyle;:</b></np>
<pre>
<prog name="StopWatchLabel2">
import javafx.scene.control.Label;
import javafx.animation.AnimationTimer;

/**
 * A custom component that acts as a simple stopwatch.  When the user clicks
 * on it, this component starts timing.  When the user clicks again,
 * it displays the time between the two clicks.  Clicking a third time
 * starts another timer, etc.  <newcode>While it is timing, the label
 * displays the number of seconds that have passed since the stop
 * watch was started.</newcode>
 */
public class StopWatchLabel2 extends Label {

    private long startTime;   // Start time of timer.
                              //   (Time is measured in milliseconds.)

    private boolean running;  // True when the timer is running.
    
    <newcode>private AnimationTimer timer;  // Used to update the timer to show
                                   // the number of seconds that have passed.</newcode>

    /**
     * Constructor sets initial text on the label to
     * "Click to start timer." and sets up a mouse event
     * handler so the label can respond to clicks.
     */
    public StopWatchLabel2() {
        super("  Click to start timer.  ");
        setOnMousePressed( e -> setRunning( !running ) );
    }


    /**
     * Tells whether the timer is currently running.
     */
    public boolean isRunning() {
        return running;
    }


    /**
     * Sets the stop watch to be running or stopped, and changes the text that
     * is shown on the label.  (This method should be called on the JavaFX
     * application thread.)
     * @param running says whether the stopwatch should be running; if this
     *    is equal to the current state, nothing is done.
     */
    public void setRunning( boolean running ) {
        if (this.running == running)
            return;
        this.running = running;
        if (running == true) {
                // Record the time and start the stopwatch.
            startTime = System.currentTimeMillis();
            <newcode>if (timer == null) {
                timer = new AnimationTimer() {
                    public void handle(long now) {
                        long elapsedTime = System.currentTimeMillis() - startTime;
                        String text = String.format(
                                 "%3.1f seconds elapsed", elapsedTime/1000.0);
                        setText(text);
                    }
                };
            }
            setText("   0.0 seconds elapsed");
            timer.start();</newcode>
        }
        else {
                // Stop the stopwatch.  Compute the elapsed time since the
                // stopwatch was started and display it.
            running = false;
            <newcode>timer.stop();</newcode>
            long endTime = System.currentTimeMillis();
            double seconds = (endTime - startTime) / 1000.0;
            setText( String.format("Time: %1.3f seconds", seconds) );
        }
    }

} // end StopWatchLabel

</prog></pre>
<np><b>The code for the program that tests the component:</b></np>
<pre>
<prog name="TestStopWatch2">
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.stage.Stage;
import javafx.scene.layout.StackPane;
import javafx.geometry.Pos;

/**
 * Shows a StopWatchLabel2.  The user can click to start a timer
 * and click again to stop it.  The elapsed time is displayed.
 */
public class TestStopWatch2 extends Application {

    public static void main(String[] args) {
        launch(args);
    }
    //------------------------------------------------------------
    
    public void start(Stage stage) {
        
        StopWatchLabel2 stopWatch = new StopWatchLabel2();
        stopWatch.setStyle("-fx-font: bold 30pt serif; -fx-background-color:#ffffee;"
                + "-fx-border-color:#008; -fx-border-width:3px; -fx-padding:20px;"
                + "-fx-text-fill: #008");
        stopWatch.setMaxSize(Double.POSITIVE_INFINITY,Double.POSITIVE_INFINITY);
        stopWatch.setAlignment(Pos.CENTER);
        
        stage.setScene( new Scene(new StackPane(stopWatch)) );
        stage.setTitle("StopWatchLabel Demo");
        stage.show();
        
    }
    
}
</prog></pre>
</exercise-code>
</exercise>



   
<exercise id="GUI2.ex.2">
<exercise-question><p>Improve the program <sourceref href="ToolPaint.java"/>,
from <localref href="GUI2.2"/>.  You can any improvements you like, but here
are some suggestions:</p>
<ul>
<li>Have separate menus for "Fill Color" and "Stroke Color".</li>
<li>Make it possible for the user to draw shapes that are both filled and
stroked.  For example, add two new tools, "Stroked Filled Rect" and
"StrokedFilledOval".</li>
<li>Add a "Line Width" menu.</li>
<li>Add keyboard accelerators for some commands (see <localref href="GUI2.5.4"/>).</li>
<li>Make it possible to use a translucent fill color.  A simple approach to this
is to use a <classname>CheckMenuItem</classname> to select either
fully opaque or 50% opaque fill. I don't advise
trying to implement translucent stroke colors, since that's more difficult.</li>
<li>Add an "Undo" command that will restore the image to what it was before
the last time it was modified.  This can be implemented by making a copy
of the image before you modify it.  It's possible to have a multi-level
undo, but that's harder and uses more memory.</li>
</ul>
<np>Remember that the <code>ToolPaint</code> program requires <sourceref href="SimpleDialogs.java"/>.</np>
</exercise-question>
<exercise-discuss><p>My solutions follows the suggestions for the features to be added.
The individual changes are not too difficult, but there are a lot of them!</p>
<p>To have separate stroke and fill colors, I added a new instance variable, <code>currentStrokeColor</code>
to represent the stroke color.  (I use the original variable, <code>currentColor</code> as the fill
color; I probably should have renamed it <code>currentFillColor</code>.)  I renamed the
"Color" menu to "Fill Color" and I made a new "Stroke Color" menu containing the same set of colors,
including a "Custom Color" command.  This was easy to do: I just copied and edited the code that made
the "Color" menu, omitting the code for the commands having to do with the background color.</p>

<p>The "Stroke Color" menu also contains a <classname>CheckMenuItem</classname> "Translucent Fill,"
which is unchecked by default.  When the user selects this command from the menu, the value of
a global <ptype>boolean</ptype> variable, <code>translucentFill</code>, is set to match the
value of the checkbox.  In the <code>mousePressed()</code> routine, the graphics contexts for the
image canvas and the overlay canvas have to be configured to use the current stroke and fill
colors.  For the fill color, the <code>currentColor</code> variable always stores a
fully opaque color.  If translucent fill is turned on, the actual fill color should have the
same RGB components as <code>currentColor</code>, but its alpha component has to be set to
0.5 for 50% transparency.  (In fact, in the end, I decided that 40% opaqueness looked better than
50%, so I used an alpha of 0.4.)  Here is the code from <code>mousePressed</code> that sets up
the graphics contexts, including both the stroke and fill colors and a
<code>currentLineWidth</code> that is also new in the program:</p>

<pre>Color fill; // currentColor, possibly with alpha set to 0.4 for a translucent fill.
if (translucentFill)
    fill = Color.color(currentColor.getRed(), currentColor.getGreen(), 
                                       currentColor.getBlue(), 0.4);
else
    fill = currentColor;
canvasGraphics.setFill(fill);  
canvasGraphics.setStroke(currentStrokeColor);
canvasGraphics.setLineWidth(currentLineWidth);
overlayGraphics.setFill(fill);
overlayGraphics.setStroke(currentStrokeColor);
overlayGraphics.setLineWidth(currentLineWidth);</pre>

<p>To control the value of the new <code>currentLineWidth</code> variable, 
I added a "Stroke Width" menu.  The commands are created and implemented
similarly to the commands in the "Color" menu:</p>

<pre>int[] lineWidths = { 1, 2, 3, 4, 5, 7, 10, 12, 15, 20 };
ToggleGroup lineWidthGroup = new ToggleGroup();
for (int i = 0; i &lt; lineWidths.length; i++) {
    RadioMenuItem item = new RadioMenuItem("Width = " + lineWidths[i]);
    item.setUserData(lineWidths[i]);
    item.setToggleGroup(lineWidthGroup);
    lineWidthMenu.getItems().add(item);
    if (i == 2)
        item.setSelected(true);
}
lineWidthGroup.selectedToggleProperty().addListener( e -> {
    Toggle t = lineWidthGroup.getSelectedToggle();
    if (t != null) {
        int width = (Integer)t.getUserData();
        currentLineWidth = width;
    }
});</pre>

<np>I didn't add a "Custom Stroke Width" command.  Perhaps I should have.</np>



<p>I added the two new Tools, "Stroked Filled Rect" and "Stroked Filled Oval."  They had to be added
to the <classname>Tools</classname> enum as well as to the "Tools" menu.  The basic method for drawing
shapes, <code>putCurrentShape(g)</code>, also needed cases for drawing the new tools:</p> 

<pre>case STROKED_FILLED_OVAL:
    putOval(g,true,startX, startY, currentX, currentY);
    putOval(g,false,startX, startY, currentX, currentY);
    break;
case STROKED_FILLED_RECT:
    putRect(g,true,startX, startY, currentX, currentY);
    putRect(g,false,startX, startY, currentX, currentY);
    break;</pre>
    
<np>The second parameter to <code>putOval()</code> and <code>putRect()</code> tells whether to
stroke the shape or fill it.  By calling the method twice, with the parameter equal to <code>true</code>
in one call and <code>false</code> in the other, the shape is both filled and stroked.  Adding these
two cases to <code>putCurrentShape()</code> was really the only thing necessary to draw the two
new shapes.</np>

<p>For the new "Undo" command, I used a simple one-level undo, so that the program just has
to save the most recent previous image.  I added an "Edit" menu to the program to hold
the new command.  (To avoid having just one item in that menu, I moved the three background
color commands from the "Color" menu to the new "Edit" menu.)  To implement the "Undo" command,
I needed to save the current image before modifying it in any way.  To get a copy of
the current picture in the canvas, I made a "snapshot" of the canvas.  I wrote a short
method to do that, and to save the snapshot in a global variable, <code>imageForRedo</code>,
of type <classname>Image</classname>:</p>

<pre>/**
 * Save a copy of the current image for the Undo operation. This is
 * called before making any change to the image.
 */
private void saveImageForUndo() {
    imageForUndo = canvas.snapshot(null,null);
    undoItem.setDisable(false); // Undo is now possible.
}</pre>

<np>This method must be called at every point in the code where the picture in the
canvas is about to be modified.  Of course, I didn't want to save an image unless the
picture actually was modified.  For example, in the original program, when drawing a
rect or an oval, it is possible that when the drag gesture ends, the rectangle or
oval is empty.  The original program draws the empty figure into the picture, even though
doing so doesn't actually draw anything.  In the new program, I check whether the
rect or oval is empty before drawing it; if it is empty, I don't want to
call <code>saveImageForRedo()</code>.  Similarly, in <code>doOpenImage()</code>,
I don't call <code>saveImageForRedo()</code> until I am sure that the new
image has been successfully loaded into the program.</np>

<p>The method that is called in response to
the "Undo" command draws the saved image into the display canvas.  Of course,
before doing that, it needs to save the current image in case the user wants to
"undo the undo," and the method needs to be careful to draw the old saved image
into the picture, not the new one:</p>

<pre>/**
 * Implements the "Undo" command.
 */
private void doUndo() {
    if (imageForUndo == null)
        return;
    Image previousUndoImage = imageForUndo; //Keep the current undo image.
    saveImageForUndo();  // Save image that is about to be replaced, for "undoing the undo".
    canvasGraphics.drawImage(previousUndoImage, 0, 0);  // Replace image with previous image.
}</pre>


<p>Finally, adding accelerators to menu commands is straightforward.  I added an accelerator
for every tool, as well as accelerators for the commands in the "File" menu.  The only
hard part was deciding what letters to use for all the different accelerators.</p>


</exercise-discuss>
<exercise-code>
<p><b>Significant changes from the original <sourceref href="ToolPaint.java">ToolPaint</sourceref> program are shown in &newcodestyle;</b></p>
<pre>
<prog name="ToolPaintPlus">
import java.awt.image.BufferedImage;
import java.io.File;
import javax.imageio.ImageIO;

import javafx.application.Application;
import javafx.embed.swing.SwingFXUtils;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.StackPane;
import javafx.scene.Scene;
import javafx.stage.FileChooser;
import javafx.stage.Stage;
import javafx.scene.control.MenuBar;
import javafx.scene.control.Alert;
import javafx.scene.control.Menu;
import javafx.scene.control.MenuItem;
import javafx.scene.control.SeparatorMenuItem;
<newcode>import javafx.scene.control.CheckMenuItem;</newcode>
import javafx.scene.control.Toggle;
import javafx.scene.control.RadioMenuItem;
import javafx.scene.control.ToggleGroup;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.paint.Color;
import javafx.scene.input.MouseEvent;
<newcode>import javafx.scene.input.KeyCombination;
import javafx.scene.shape.StrokeLineCap;</newcode>

import javafx.scene.image.WritableImage;
import javafx.scene.image.Image;
import javafx.scene.image.PixelReader;
import javafx.scene.image.PixelWriter;
import javafx.scene.SnapshotParameters;
import javafx.geometry.Rectangle2D;

/**
 * A simple paint program that lets the user paint with several
 * different tools, including a "smudge" tool that uses fairly
 * sophisticated pixel manipulation.  The program also demonstrates
 * using a transparent "overlay" canvas to implement some of the
 * tools.  The window for this program is not resizable.
 */
public class ToolPaintPlus extends Application {

    public static void main(String[] args) {
        launch(args);
    }

    private Canvas canvas; // The canvas on which the image is drawn.
    private GraphicsContext canvasGraphics;  // The graphics context for the canvas.

    private Canvas overlay; // A transparent canvas that lies on top of
                            // the image canvas, used for temporarily
                            // drawing some shapes during a mouse drag.
    private GraphicsContext overlayGraphics;  // Graphics context for overlay.


    /**
     * The possible drawing tools in this program.  (The CURVE tool allows the
     * user to sketch a free-hand curve, while the LINE tool draws a line
     * between two points.  The SMUDGE tool lets the user "spread paint around"
     * with the mouse.  The ERASE tool erases with a 10-by-10 pixel rectangle.)
     */
    private enum Tool { LINE, RECT, OVAL, FILLED_RECT, FILLED_OVAL, 
                           <newcode>STROKED_FILLED_RECT, STROKED_FILLED_OVAL,</newcode> CURVE, SMUDGE, ERASE }
    

    private Tool currentTool = Tool.CURVE;  // The current drawing tool.

    private Color currentColor = Color.BLACK; // The current <newcode>fill</newcode> color.  This color
                                              // is fully opaque.
    <newcode>private boolean translucentFill;  // When this is true, the fill color that is
                                      //   used takes its RGB components from the
                                      //   currntColor, but its alpha component is 0.4.</newcode>
    
    <newcode>private Color currentStrokeColor = Color.BLACK;   // The current stroke color.</newcode>

    private Color backgroundColor = Color.WHITE;  // The current background color.
    
    <newcode>private double currentLineWidth = 2;  // The line width used for all strokes.
    
    private MenuItem undoItem;   // The "Undo" menu item.  This is needed so that
                                 // it can be enabled when an undo becomes available.
    private Image imageForUndo;  // Stores a snapshot of the canvas before the
                                 // most recent change to the image.  This is used
                                 // to implement the "Undo" command.  Note that
                                 // using Undo twice in a row will "undo the undo."</newcode>

    /* Some variables that are used during dragging. */
    private boolean dragging;     // is a drag in progress?
    private int startX, startY;   // start point of drag
    private int prevX, prevY;     // previous mouse location during a drag
    private int currentX, currentY;  // current mouse position during a drag
    <newcode>private boolean firstMove;    // used in mouseDragged to tell whether this
                                  //    is the first time the mouse has moved.</newcode>

    /* Some variables used to implement the smudge tool. */
    private double[][] smudgeRed, smudgeGreen, smudgeBlue;
    private WritableImage pixels; // a 9-by-9 block of pixels from the canvas  
    private PixelReader pixelReader;  // for reading colors from pixels
    private SnapshotParameters snapshotParams;  // used for snapshotting the canvas
    private PixelWriter pixelWriter;  // for writing pixels to the canvas

    private Stage window;  // The program's window.
    
    /**
     * Create the canvas and the overlayCanvas, and set up mouse handling,
     * configure and show the window.
     */
    public void start(Stage stage) {
        
        window = stage;

        int width = 800;   // size of canvas; can be changed here
        int height = 600;
        
        canvas = new Canvas(width,height);
        canvasGraphics = canvas.getGraphicsContext2D();
        canvasGraphics.setFill(backgroundColor);
        canvasGraphics.fillRect(0,0,width,height);
        overlay = new Canvas(width,height);
        overlayGraphics = overlay.getGraphicsContext2D();
        overlay.setOnMousePressed( e -> mousePressed(e) );
        overlay.setOnMouseDragged( e -> mouseDragged(e) );
        overlay.setOnMouseReleased( e -> mouseReleased(e) );
        <newcode>// canvasGraphics.setLineWidth(2);  // line width is now set in mousePressed
        // overlayGraphics.setLineWidth(2);
        canvasGraphics.setLineCap(StrokeLineCap.ROUND);  // will look better for thick strokes
        overlayGraphics.setLineCap(StrokeLineCap.ROUND);</newcode>
        
        StackPane canvasHolder = new StackPane(canvas,overlay);
        BorderPane root = new BorderPane(canvasHolder);
        root.setTop( makeMenuBar() );
        
        stage.setScene( new Scene(root) );
        stage.setTitle("A Simple Paint Program");
        stage.setResizable(false);
        stage.show();

    } // end start()


    /**
     * A utility method to draw the current shape in a given graphics context.
     * It draws the correct shape for the current tool in a rectangle whose
     * corners are given by the starting position of the mouse and the current
     * position of the mouse.  This method is not used when the current tool 
     * is Tool.CURVE or Tool.ERASE, or Tool.SMUDGE.  For other tools, it is
     * used to draw the shape to the overlay canvas during a drag operation;
     * then, when the drag ends, it is used to draw the shape to the main
     * canvas.  The shape is defined by the tool and by the two points
     * (startX,startY) and (currentX,currentY).
     */
    private void putCurrentShape(GraphicsContext g) {
        switch (currentTool) {
        case LINE:
            <newcode>if (startX != currentX || startY != currentY)</newcode>
                g.strokeLine(startX, startY, currentX, currentY);
            break;
        case OVAL:
            putOval(g,false,startX, startY, currentX, currentY);
            break;
        case RECT:
            putRect(g,false,startX, startY, currentX, currentY);
            break;
        case FILLED_OVAL:
            putOval(g,true,startX, startY, currentX, currentY);
            break;
        case FILLED_RECT:
            putRect(g,true,startX, startY, currentX, currentY);
            break;
        <newcode>case STROKED_FILLED_OVAL:
            putOval(g,true,startX, startY, currentX, currentY);
            putOval(g,false,startX, startY, currentX, currentY);
            break;
        case STROKED_FILLED_RECT:
            putRect(g,true,startX, startY, currentX, currentY);
            putRect(g,false,startX, startY, currentX, currentY);
            break;</newcode>
        default:  // not called in other cases
            break;
        }
    }


    /**
     * Draws a filled or unfilled rectangle with corners at the points (x1,y1)
     * and (x2,y2).  Nothing is drawn if x1 == x2 or y1 == y2.
     * (This method translates from an opposite-corners definition of the rectangle
     * to the upper-left-corner-width-and-height definition used for drawing.)
     * @param g the graphics context where the rectangle is drawn
     * @param filled tells whether to draw a filled or unfilled rectangle.
     */
    private void putRect(GraphicsContext g, boolean filled, int x1, int y1, int x2, int y2) {
        if (x1 == x2 || y1 == y2)
            return;
        int x = Math.min(x1,x2);    // get upper left corner, (x,y)
        int y = Math.min(y1,y2);
        int w = Math.abs(x1 - x2);  // get width and height
        int h = Math.abs(y1 - y2);
        if (filled)
            g.fillRect(x,y,w,h);
        else
            g.strokeRect(x,y,w,h);
    }


    /**
     * Draws a filled or unfilled oval in the rectangle with corners at the 
     * points (x1,y1) and (x2,y2).  Nothing is drawn if x1 == x2 or y1 == y2.
     * @param g the graphics context where the oval is drawn
     * @param filled tells whether to draw a filled or unfilled oval.
     */
    private void putOval(GraphicsContext g, boolean filled, int x1, int y1, int x2, int y2) {
        if (x1 == x2 || y1 == y2)
            return;
        int x = Math.min(x1,x2);    // get upper left corner, (x,y)
        int y = Math.min(y1,y2);
        int w = Math.abs(x1 - x2);  // get width and height
        int h = Math.abs(y1 - y2);
        if (filled)
            g.fillOval(x,y,w,h);
        else
            g.strokeOval(x,y,w,h);
    }

    
    /**
     * Creates a menu bar for use with this program, with "Color"
     * and "Tool" menus.
     */
    private MenuBar makeMenuBar() {
        MenuBar menubar = new MenuBar();
        Menu fileMenu = new Menu("File");
        <newcode>Menu editMenu = new Menu("Edit");</newcode>
        Menu colorMenu = new Menu("<newcode>Fill</newcode> Color");
        <newcode>Menu strokeColorMenu = new Menu("Stroke Color");
        Menu lineWidthMenu = new Menu("Stroke Width");</newcode>
        Menu toolMenu = new Menu("Tool");
        menubar.getMenus().add(fileMenu);
        <newcode>menubar.getMenus().add(editMenu);</newcode>
        menubar.getMenus().add(toolMenu);
        menubar.getMenus().add(colorMenu);
        <newcode>menubar.getMenus().add(strokeColorMenu);
        menubar.getMenus().add(lineWidthMenu);</newcode>
        
        /* Add items to the File menu. */
        
        MenuItem openImage = new MenuItem("Load Image...");
        openImage.setOnAction( e -> doOpenImage() );
        openImage.setAccelerator( KeyCombination.valueOf("shortcut+O"));
        fileMenu.getItems().add(openImage);
        MenuItem saveImage = new MenuItem("Save PNG Image...");
        saveImage.setOnAction( e -> doSaveImage() );
        saveImage.setAccelerator( KeyCombination.valueOf("shortcut+S"));
        fileMenu.getItems().add(saveImage);
        fileMenu.getItems().add( new SeparatorMenuItem() );
        MenuItem quit = new MenuItem("Quit");
        quit.setOnAction( e -> System.exit(0) );
        quit.setAccelerator( KeyCombination.valueOf("shortcut+Q"));
        fileMenu.getItems().add(quit);
        
        <newcode>/* Add items to the Edit menu.  (All items except "Undo" were in the
         * "Color" menu in the previous version.) */
        
        undoItem = new MenuItem("Undo");
        undoItem.setDisable(true); // will be enabled when some change is made
        undoItem.setOnAction( e -> doUndo() );
        undoItem.setAccelerator( KeyCombination.valueOf("shortcut+Z"));
        editMenu.getItems().add(undoItem);</newcode>
        editMenu.getItems().add( new SeparatorMenuItem() );
        MenuItem clear = new MenuItem("Clear to Background Color");
        clear.setOnAction( e -> {  // Fill main canvas with current background color.
            <newcode>saveImageForUndo();</newcode>
            canvasGraphics.setFill(backgroundColor);
            canvasGraphics.fillRect(0,0,canvas.getWidth(),canvas.getHeight());
        });
        <newcode>clear.setAccelerator( KeyCombination.valueOf("shortcut+K") );</newcode>
        editMenu.getItems().add(clear);
        MenuItem fill = new MenuItem("Fill with Drawing Color");
        fill.setOnAction( e -> {  // Fill main canvas with current drawing color, but
                                  // don't change the background color.  (The erase
                                  // tool will still erase to the (old) background color.)
            <newcode>saveImageForUndo();</newcode>
            canvasGraphics.setFill(currentColor);
            canvasGraphics.fillRect(0,0,canvas.getWidth(),canvas.getHeight());
        });
        editMenu.getItems().add(fill);
        editMenu.getItems().add(new SeparatorMenuItem());
        MenuItem setBG = new MenuItem("Fill and Set Background...");
        setBG.setOnAction( e -> {
                 // User can select a new background color from a dialog box.  If the
                 // dialog box is not canceled, the selected color becomes the background
                 // color, and the canvas is filled with that background color.
            Color c = SimpleDialogs.colorChooser(backgroundColor, "Select a Background Color");
            if (c != null) {
                <newcode>saveImageForUndo();</newcode>
                backgroundColor = c;
                canvasGraphics.setFill(c);
                canvasGraphics.fillRect(0,0,canvas.getWidth(),canvas.getHeight());
            }
        });
        <newcode>setBG.setAccelerator( KeyCombination.valueOf("shortcut+B") );</newcode>
        editMenu.getItems().add(setBG);
        
        /* Color choices are given by RadioMenuItems, controlled by
         * a ToggleGroup.  Each choice corresponds to a standard color,
         * except for a "Custom Drawing Color" item that calls up
         * a color choice dialog box.  The same set of colors is used
         * in the "Fill Color" menu and in the "Stroke Color" menu.*/
        
        Color[] colors = { // Standard colors available in the menu.
                Color.BLACK, Color.WHITE, Color.RED, Color.GREEN, 
                Color.BLUE, Color.YELLOW, Color.CYAN, Color.PURPLE, Color.GRAY};
        String[] colorNames = { // Names for the colors, used to construct menu items.
                "Black", "White", "Red", "Green", 
                "Blue", "Yellow", "Cyan", "Purple", "Gray"};
        
        /* First, set up the "Fill Color menu. */
        
        ToggleGroup colorGroup = new ToggleGroup();
        for (int i = 0; i &lt; colors.length; i++) {
            RadioMenuItem item = new RadioMenuItem("Fill with " + colorNames[i]);
            item.setUserData(colors[i]); // Stash the actual color in the menu item's UserData
            item.setToggleGroup(colorGroup);
            colorMenu.getItems().add(item);
            if (i == 0)
                item.setSelected(true);  // Initially selected color is black.
        }
        RadioMenuItem customColor = new RadioMenuItem("Custom Fill Color...");
        customColor.setToggleGroup(colorGroup);
        customColor.setOnAction( e -> {
               // For the custom color selection, use a dialog box to get an 
               // arbitrary color from the user.  This has to be done in an
               // ActionEvent handler, since it needs to happen even the user selects
               // Custom Drawing Color when it is already selected.  (In that case,
               // the selected toggle does not change.
            customColor.setSelected(true);
            Color c = SimpleDialogs.colorChooser(currentColor, "Select a Color to Use For Filling Shapes");
            if (c != null)  // c is null if user cancels the dialog
                currentColor = c;
        });
        colorMenu.getItems().add(customColor);
        colorGroup.selectedToggleProperty().addListener( e -> {
               // Sets the color, when one of the standard colors is selected.
               // This does not handle the Custom Color option.  Note that
               // when the user chooses a new radio menu item, the selected toggle
               // first changes to null as the old menu item is deselected, then
               // changes to the newly selected menu item.
            Toggle t = colorGroup.getSelectedToggle();  // the selected RadioMenuItem
            if (t != null &amp;&amp; t != customColor) {
                   // The color associated with this menu item was stashed
                   // in the UserData of the menu item, t.
                currentColor = (Color)t.getUserData();
            }
        });
        colorMenu.getItems().add( new SeparatorMenuItem() );
        CheckMenuItem translucent = new CheckMenuItem("Use Translucent Fill");
        translucent.setOnAction( e -> translucentFill = translucent.isSelected() );
        colorMenu.getItems().add(translucent);
        
        <newcode>/* Second, set up the "Stroke Color" menu in a similar way,
         * but without the extra commands. */
        
        ToggleGroup strokeColorGroup = new ToggleGroup();
        for (int i = 0; i &lt; colors.length; i++) {
            RadioMenuItem item = new RadioMenuItem("Stroke with " + colorNames[i]);
            item.setUserData(colors[i]); 
            item.setToggleGroup(strokeColorGroup);
            strokeColorMenu.getItems().add(item);
            if (i == 0)
                item.setSelected(true);  // Initially selected color is black.
        }
        RadioMenuItem customStrokeColor = new RadioMenuItem("Custom Stroke Color...");
        customStrokeColor.setToggleGroup(strokeColorGroup);
        customStrokeColor.setOnAction( e -> {
            customStrokeColor.setSelected(true);
            Color c = SimpleDialogs.colorChooser(currentStrokeColor, "Select a Color to Use For Strokes");
            if (c != null)
                currentStrokeColor = c;
        });
        strokeColorMenu.getItems().add(customStrokeColor);
        strokeColorGroup.selectedToggleProperty().addListener( e -> {
            Toggle t = strokeColorGroup.getSelectedToggle();
            if (t != null &amp;&amp; t != customStrokeColor) {
                currentStrokeColor = (Color)t.getUserData();
            }
        });
        
        /* Set up the "Stroke Width" menu. */
        
        int[] lineWidths = { 1, 2, 3, 4, 5, 7, 10, 12, 15, 20 };
        ToggleGroup lineWidthGroup = new ToggleGroup();
        for (int i = 0; i &lt; lineWidths.length; i++) {
            RadioMenuItem item = new RadioMenuItem("Width = " + lineWidths[i]);
            item.setUserData(lineWidths[i]);
            item.setToggleGroup(lineWidthGroup);
            lineWidthMenu.getItems().add(item);
            if (i == 2)
                item.setSelected(true);
        }
        lineWidthGroup.selectedToggleProperty().addListener( e -> {
            Toggle t = lineWidthGroup.getSelectedToggle();
            if (t != null) {
                int width = (Integer)t.getUserData();
                currentLineWidth = width;
            }
        });</newcode>

        /* The User selects a drawing tool from the tool menu.  The menu contains
         * an entry for each available tool.  Tools are represented by RadioMenuItems,
         * controlled by a ToggleGroup. */
        
        Tool[] tools = { // The available tools in the order they appear in the menu.
                Tool.CURVE, Tool.LINE, Tool.RECT, Tool.OVAL, Tool.FILLED_RECT, 
                Tool.FILLED_OVAL, <newcode>Tool.STROKED_FILLED_RECT, Tool.STROKED_FILLED_OVAL,</newcode>
                Tool.SMUDGE, Tool.ERASE };
        String[] toolNames = { // Names for the tools, used as text in the menu items.
                "Curve", "Line", "Rectangle", "Oval", "Filled Rectangle", 
                "Filled Oval", <newcode>"Stroked Filled Rect", "Stroked Filled Oval",</newcode>
                "Smudge", "Erase" };
        <newcode>String[] toolAccelerators = { // accelerators for tool command; will be added to "shortcut+"
                "C", "L", "R", "V", "alt+R",
                "alt+V", "shift+R", "shift+V",
                "M", "E" };</newcode>
        
        ToggleGroup toolGroup = new ToggleGroup();
        for (int i = 0; i &lt; tools.length; i++) {
            RadioMenuItem item = new RadioMenuItem(toolNames[i]);
            item.setUserData(tools[i]);  // Stash the actual tool in the menu items' UserData
            item.setToggleGroup(toolGroup);
            <newcode>item.setAccelerator( KeyCombination.valueOf("shortcut+" + toolAccelerators[i]) );</newcode>
            toolMenu.getItems().add(item);
            if (i == 0)
                item.setSelected(true);  // Curve tool is initially selected
            if (i == 0 || i == 5)  // Separators before and after the shape tools.
                toolMenu.getItems().add(new SeparatorMenuItem() );
        }
        toolGroup.selectedToggleProperty().addListener( e -> {
            Toggle t = toolGroup.getSelectedToggle();  // The selected RadioMenuItem
            if (t != null)
                currentTool = (Tool)t.getUserData(); // the actual tool was stashed in the UserData.
        });

        return menubar;
        
    } // end makeMenuBar

    
    /**
     * When the ERASE or SMUDGE tools are used and the mouse jumps
     * from (x1,y1) to (x2,y2), the tool has to be applied to a
     * line of pixel positions between the two points in order to
     * be sure to cover the entire line that the mouse moves along.
     */
    private void applyToolAlongLine(int x1, int y1, int x2, int y2) {
        int w = (int)canvas.getWidth();   // (for SMUDGE only)
        int h = (int)canvas.getHeight();  // (for SMUDGE only)
        int dist = Math.max(Math.abs(x2-x1),Math.abs(y2-y1));
            // dist is the number of points along the line from
            // (x1,y1) to (x2,y2) at which the tool will be applied.
        double dx = (double)(x2-x1)/dist;
        double dy = (double)(y2-y1)/dist;
        for (int d = 1; d &lt;= dist; d++) {
                // Apply the tool at one of the points (x,y) along the
                // line from (x1,y1) to (x2,y2).
            int x = (int)Math.round(x1 + dx*d);
            int y = (int)Math.round(y1 + dy*d);
            if (currentTool == Tool.ERASE) {
                    // Erase a 10-by-10 block of pixels around (x,y)
                canvasGraphics.fillRect(x-5,y-5,10,10);
            }
            else { 
                    // For the SMUDGE tool, blend some of the color from
                    // the smudgeRed, smudgeGreen, and smudgeBlue arrays
                    // into the pixels in a 7-by-7 block around (x,y), and
                    // vice versa.  The effect is to smear out the color
                    // of pixels that are visited by the tool.
                snapshotParams.setViewport(new Rectangle2D(x-4,y-4,9,9));
                canvas.snapshot(snapshotParams, pixels);
                for (int j = 0; j &lt; 9; j++) {
                    int c = x - 4 + j;
                    for (int i = 0; i &lt; 9; i++) {
                        int r = y - 4 + i;
                        if ( r >= 0 &amp;&amp; r &lt; h &amp;&amp; c >= 0 &amp;&amp; c &lt; w &amp;&amp; smudgeRed[i][j] != -1) {
                            Color oldColor = pixelReader.getColor(j,i);
                            double newRed = (oldColor.getRed()*0.8 + smudgeRed[i][j]*0.2);
                            double newGreen = (oldColor.getGreen()*0.8 + smudgeGreen[i][j]*0.2);
                            double newBlue = (oldColor.getBlue()*0.8 + smudgeBlue[i][j]*0.2);
                            pixelWriter.setColor(c, r,Color.color(newRed,newGreen,newBlue));
                            smudgeRed[i][j] = oldColor.getRed()*0.2 + smudgeRed[i][j]*0.8;
                            smudgeGreen[i][j] = oldColor.getGreen()*0.2 + smudgeGreen[i][j]*0.8;
                            smudgeBlue[i][j] = oldColor.getBlue()*0.2 + smudgeBlue[i][j]*0.8;
                        }
                    }
                }
            }
        }
    } // end applyToolAlongLine


    /**
     * Start a drag operation. 
     */
    private void mousePressed(MouseEvent evt) {
        startX = prevX = currentX = (int)evt.getX();
        startY = prevY = currentY = (int)evt.getY();
        dragging = true;
        <newcode>firstMove = true;</newcode>
        
        // make sure we are drawing with the right properties
        
        <newcode>Color fill; // currentColor, possibly with alpha set to 0.4 for a translucent fill.
        if (translucentFill)
            fill = Color.color(currentColor.getRed(), currentColor.getGreen(), 
                                                                    currentColor.getBlue(), 0.4);
        else
            fill = currentColor;
        canvasGraphics.setFill(fill);  
        canvasGraphics.setStroke(currentStrokeColor);
        canvasGraphics.setLineWidth(currentLineWidth);
        overlayGraphics.setFill(fill);
        overlayGraphics.setStroke(currentStrokeColor);
        overlayGraphics.setLineWidth(currentLineWidth);</newcode>
        
        if (currentTool == Tool.ERASE) {
                // Erase a 10-by-10 block around the starting mouse position.
            canvasGraphics.setFill(backgroundColor);  // change the color when using erase
            canvasGraphics.fillRect(startX-5,startY-5,10,10);
        }
        else if (currentTool == Tool.SMUDGE) {
                // Record the colors in a 7-by-7 block of pixels around the
                // starting mouse position into the arrays smudgeRed, 
                // smudgeGreen, and smudgeBlue.  These arrays hold the
                // red, green, and blue components of the colors.
            if (smudgeRed == null) {
                    // Create all variables needed for smudge, if not already done.
                pixels = new WritableImage(9,9);  
                pixelReader = pixels.getPixelReader();
                snapshotParams = new SnapshotParameters();
                smudgeRed = new double[9][9]; 
                smudgeGreen = new double[9][9];
                smudgeBlue = new double[9][9];
                pixelWriter = canvasGraphics.getPixelWriter();
            }
            snapshotParams.setViewport(new Rectangle2D(startX-4,startY-4,9,9));
            canvas.snapshot(snapshotParams, pixels);
            int h = (int)canvas.getHeight();
            int w = (int)canvas.getWidth();
            for (int j = 0; j &lt; 9; j++) {  // row in the snapshot
                int r = startY + j - 4;  // the corresponding row in the canvas
                for (int i = 0; i &lt; 9; i++) {  // column in the snapshot
                    int c = startX + i - 4;  // the corresponding column in canvas
                    if (r &lt; 0 || r >= h || c &lt; 0 || c >= w) {
                            // The point (i,j) is outside the canvas.
                            // A -1 in the smudgeRed array indicates that the
                            // corresponding pixel was outside the canvas.
                        smudgeRed[j][i] = -1;
                    }
                    else {
                        Color color = pixelReader.getColor(i, j); // get color from snapshot
                        smudgeRed[j][i] = color.getRed();
                        smudgeGreen[j][i] = color.getGreen();
                        smudgeBlue[j][i] = color.getBlue();
                    }
                }
            }
        }
    }

    
    /**
     * Continue a drag operation when the user drags the mouse.
     * For the CURVE tool, a line is drawn from the previous mouse
     * position to the current mouse position in the main canvas.
     * For shape tools like LINE and FILLED_RECT, the shape is drawn
     * to the overlay canvas after first clearing the overlay canvas.  
     * For the SMUDGE and ERASE tools, the tool is applied along a 
     * line from the previous mouse position to the current position,
     * on the main canvas.
     */
    private void mouseDragged(MouseEvent evt) {
        if (!dragging)
            return;
        currentX = (int)evt.getX();
        currentY = (int)evt.getY();
        if (currentTool == Tool.CURVE) {
            <newcode>if (firstMove)
                saveImageForUndo();</newcode>
            canvasGraphics.strokeLine(prevX,prevY,currentX,currentY);
        }
        else if (currentTool == Tool.ERASE || currentTool == Tool.SMUDGE) {
            <newcode>if (firstMove)
                saveImageForUndo();</newcode>
            applyToolAlongLine(prevX,prevY,currentX,currentY);
        }
        else  {  // tool is a shape that has to be drawn to overlay canvas
            overlayGraphics.clearRect(0,0,overlay.getWidth(),overlay.getHeight());
            putCurrentShape(overlayGraphics);
        }
        prevX = currentX;
        prevY = currentY;
        <newcode>firstMove = false;</newcode>
    }

    
    /**
     * Finish a mouse drag operation.  Nothing is done unless the current tool
     * is a shape tool.  For shape tools, the user's shape is drawn to the
     * main canvas, making it a permanent part of the picture, and
     * the overlay canvas, which was used for the shape during dragging,
     * is cleared.
     */
    private void mouseReleased(MouseEvent evt) {
        dragging = false;
        if (currentTool != Tool.CURVE &amp;&amp; 
                currentTool != Tool.ERASE &amp;&amp; currentTool != Tool.SMUDGE) {
            <newcode>if (currentTool == Tool.LINE) {
                if (currentX == startX &amp;&amp; currentY == startY) {
                    // mouse is at starting position; there is no line to draw.
                    return;
                }
            }
            else if (currentX == startX || currentY == startY) {
                // The shape has width=0 or height=0 and so should not be drawn.
                return;
            }
            saveImageForUndo();</newcode>
            putCurrentShape(canvasGraphics);
            overlayGraphics.clearRect(0,0,overlay.getWidth(),overlay.getHeight());
        }
    }
    
    
    <newcode>/**
     * Save a copy of the current image for the Undo operation. This is
     * called before making any change to the image.
     */
    private void saveImageForUndo() {
        imageForUndo = canvas.snapshot(null,null);
        undoItem.setDisable(false);
    }
    
    
    /**
     * Implements the "Undo" command.
     */
    private void doUndo() {
        if (imageForUndo == null)
            return;
        Image previousUndoImage = imageForUndo;
        saveImageForUndo();  // Save image that is about to be replaced, for "undoing the undo".
        canvasGraphics.drawImage(previousUndoImage, 0, 0);  // Replace image with previous image.
    }</newcode>
    
    /**
     * Reads an image from a file and draws it to the canvas,
     * scaling it so it fills the canvas.
     */
    private void doOpenImage() {
        FileChooser fileDialog = new FileChooser(); 
        fileDialog.setInitialFileName("");
        fileDialog.setInitialDirectory(
                               new File( System.getProperty("user.home") ) );
        fileDialog.setTitle("Select Image File to Load");
        File selectedFile = fileDialog.showOpenDialog(window);
        if ( selectedFile == null )
            return;  // User did not select a file.
        Image image = new Image("file:" + selectedFile);
        if (image.isError()) {
            Alert errorAlert = new Alert(Alert.AlertType.ERROR,
                    "Sorry, an error occurred while\ntrying to load the file:\n"
                         + image.getException().getMessage());
            errorAlert.showAndWait();
            return;
        }
        <newcode>saveImageForUndo();</newcode>
        canvasGraphics.drawImage(image,0,0,canvas.getWidth(),canvas.getHeight());
    }

    
    /**
     * Saves the user's sketch as an image file in PNG format.
     */
    private void doSaveImage() {
        FileChooser fileDialog = new FileChooser(); 
        fileDialog.setInitialFileName("imagefile.png");
        fileDialog.setInitialDirectory(
                         new File( System.getProperty("user.home") ) );
        fileDialog.setTitle("Select File to Save. Name MUST end with .png!");
        File selectedFile = fileDialog.showSaveDialog(window);
        if ( selectedFile == null )
            return;  // User did not select a file.
        try {
            Image canvasImage = canvas.snapshot(null,null);
            BufferedImage image = SwingFXUtils.fromFXImage(canvasImage,null);
            String filename = selectedFile.getName().toLowerCase();
            if ( ! filename.endsWith(".png")) {
                throw new Exception("The file name must end with \".png\".");
            }
            boolean hasFormat = ImageIO.write(image,"PNG",selectedFile);
            if ( ! hasFormat ) { // (this should never happen)
                throw new Exception( "PNG format not available.");
            }
        }
        catch (Exception e) {
            Alert errorAlert = new Alert(Alert.AlertType.ERROR,
                   "Sorry, an error occurred while\ntrying to save the image:\n"
                         + e.getMessage());
            errorAlert.showAndWait();
        }    
    }
    


} // end class ToolPaintPlus
</prog></pre>
</exercise-code>
</exercise>



         
<exercise>
<exercise-question><p>The sample program <sourceref chapter="11" href="PhoneDirectoryFileDemo.java"/>
from <localref href="IO.3.2"/> keeps data for a "phone directory" in a file in the user's
home directory.  <localref href="IO.ex.5"/> asked you to revise that program to
use an XML format for the data.  Both programs have a simple command-line user
interface.  For this exercise, you should provide a GUI interface for the
phone directory data.  You can base your program either on the original sample
program or on the modified XML version from the exercise.  Use a <classname>TableView</classname>
to hold the data.  The user should be able to edit all the entries in the
table.  Also, the user should be able to add and delete rows.  Include either
buttons or menu commands that can be used to perform these actions.  The
delete command should delete the selected row, if any.   New rows should be
added at the end of the table.</p>
<p>Your program should load data from the file when it starts and save data to the
file when it ends, just as the two previous programs do.  For a GUI program, you need to save the
data when the user closes the window, which ends the program. To do that, you
can add a listener to the program's <classname>Stage</classname> to handle
the WindowHidden event.  For an example of using that event, the Mandelbrot Viewer program from 
<localref href="GUI2.5"/> uses it to save preferences when the program ends.
For an example of creating an editable table, see <sourceref href="ScatterPlotTableDemo.java"/>.</p>
<p>(I suggest keeping things simple.  You not being asked to write a real phone book application!
The point is mostly to make an editable table.  My program has text input boxes for name and number, and
an "Add" button for adding a new entry containing the input in those boxes. 
My program always saves the data, whether or not the user has
changed it.   The interface will be poor:  The user has to double-click a cell to edit it and press
return to finish the edit and save the new value.  It is possible to make a
table with a better editing interface, but to do that, you need to write a new 
<classname>CellFactory</classname> class for the table.)</p>
</exercise-question>
<exercise-discuss>
<p>To make a table with two columns holding names and phone numbers, we need a class to represent
a row in the table.  For an editable table, the individual data values in the class should be 
stored in observable properties.  I wrote a simple nested class, <classname>PhoneEntry</classname>, for that
purpose, similar to the <classname>Point</classname> class that was used to represent rows in the
<code>ScatterPlotTableDemo</code> program:</p>

<pre>/**
 * A class that represents one phone book entry, with
 * observable properties nameProperty() and numberProperty()
 * to hold the data for the entry. (Note that the table must
 * be public and the nameProperty() and numberProperty() method
 * must be public for this class to work with an editable table.)
 */
public static class PhoneEntry {
    StringProperty name;
    StringProperty number;
    PhoneEntry(String name, String number) {
        this.name = new SimpleStringProperty(name);
        this.number = new SimpleStringProperty(number);
    }
    public StringProperty nameProperty() {
        return name;
    }
    public StringProperty numberProperty() {
        return number;
    }
}</pre>

<np>The table can then be created as a variable of type <code>TableView&lt;PhoneEntry&gt;</code>.
The data for the phone book will be stored in the list of items in the table, which is of
type <atype>ObservableList&lt;PhoneEntry&gt;</atype>.  The program uses a variable,
<code>phoneEntries</code>, to refer to that list:</np>

<pre>ObservableList&lt;PhoneEntry> phoneEntries = phoneBook.getItems();</pre>

<p>The two table columns have to be created and configured.  Again, this is similar to what was
done in <code>ScatterPlotTableDemo</code>, except that in this program, the user is allowed
to sort and resize the columns  And since the values in the cells are <classname>Strings</classname>
rather than <classname>Doubles</classname>, no <classname>StringConverter</classname> is
needed for the cell factory.  The "Name" column is created as follows:</p>

<pre>TableColumn&lt;PhoneEntry, String> nameColumn = new TableColumn&lt;>("Name");
nameColumn.setCellValueFactory( new PropertyValueFactory&lt;PhoneEntry, String>("name") );
nameColumn.setCellFactory( TextFieldTableCell.forTableColumn() );
nameColumn.setPrefWidth(200);  // (Default size is too small)
phoneBook.getColumns().add(nameColumn);
nameColumn.setEditable(true);</pre>

<p>The program has "Add" and "Delete" buttons for adding and deleting phone entries.
(This part is actually modeled on <sourceref href="EditListDemo.java"/> rather than
<code>ScatterPlotListDemo</code>.)  At first, I tried just adding an empty row
when the user clicks "Add" and leaving it up to the user to fill in the name
and number in that row, but I found that it was hard even to see the empty
row in the table.  So instead, I added text input boxes for the new name and
number, and the "Add" button adds a new entry containing the data from those
input boxes.  This also allowed me to check that the two input boxes were both
non-empty before adding the entry to the table, so that I could avoid having
rows in the table where the name or number was empty.</p>

<p>For the file that stores the phone book data,
I used the simple data format from the original program.  That program already had code
for loading and saving the data, at the beginning and end of its <code>main()</code>
routine.  I copied that code into two instance methods named <code>loadPhoneBook()</code>
and <code>savePhoneBook()</code>, and I modified the code to use data stored in
an <classname>ObservableList</classname> instead of in a <classname>Map</classname>.  The <code>savePhoneBook()</code>
method is called by an event handler when the window is closed, as suggested in the exercise:</p>

<pre>stage.setOnHidden( e -> savePhoneBook(dataFile, phoneEntries) );</pre>

</exercise-discuss>
<exercise-code>
<pre>
<prog name="PhoneDirectoryGUI">
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.stage.Stage;
import javafx.scene.control.Alert;
import javafx.scene.control.Button;
import javafx.scene.control.TextField;
import javafx.scene.control.TableView;
import javafx.scene.control.TableColumn;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.control.cell.TextFieldTableCell;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.geometry.Insets;
import javafx.beans.property.StringProperty;
import javafx.beans.property.SimpleStringProperty;
import javafx.collections.ObservableList;

import java.io.File;
import java.io.PrintWriter;
import java.io.IOException;
import java.util.Scanner;
import java.util.List;


/**
 * Lets the user edit a list names and phone numbers in a TableView.
 * The list is read from the file named ".phone_book_demo" in the
 * user's home directory, and the possibly changed data is written
 * back to that file when the program ends.  The file uses a
 * simple format: each line contains a name and a phone number,
 * separated by "%".  (The format can't correctly handle names that 
 * contain a '%' character, which should not be too likely.)
 */
public class PhoneDirectoryGUI extends Application {

    public static void main(String[] args) {
        launch();    
    }
    // -------------------------------------------------------------------------
    
    /**
     * The name of the file in which the phone book data is kept.  The
     * file is stored in the user's home directory.  The "." at the
     * beginning of the file name means that the file will be a
     * "hidden" file on Unix-based computers, including Linux and
     * MacOS.
     */
    private static String DATA_FILE_NAME = ".phone_book_demo";


    /**
     * A class that represents one represents one phone book entry,
     * with observable properties nameProperty() and numberProperty()
     * to hold the data for the entry. (Note that the table must
     * be public and the nameProperty() and numberProperty() method
     * must be public for this class to work with an editable table.)
     */
    public static class PhoneEntry {
        StringProperty name;
        StringProperty number;
        PhoneEntry(String name, String number) {
            this.name = new SimpleStringProperty(name);
            this.number = new SimpleStringProperty(number);
        }
        public StringProperty nameProperty() {
            return name;
        }
        public StringProperty numberProperty() {
            return number;
        }
    }
    
    
    /**
     * start() method creates the table, reads the existing data file if
     * there is one, and sets up the GUI.  It installs a WindowHidden
     * event handler on the stage that will save the data when the window
     * is closed.
     */
    public void start(Stage stage) {
        
        /* Create a dataFile variable of type File to represent the
         * data file that is stored in the user's home directory. */

        File userHomeDirectory = new File( System.getProperty("user.home") );
        File dataFile = new File( userHomeDirectory, DATA_FILE_NAME );

        /* Create a TableView to hold the data for the phonebook, and
         * load the existing phonebook data from the file into the table. 
         * The loadPhoneBook method will not return if an error occurs. */

        TableView&lt;PhoneEntry> phoneBook = new TableView&lt;>();
        phoneBook.setEditable(true);
        phoneBook.setPrefSize(420,350);
        ObservableList&lt;PhoneEntry> phoneEntries = phoneBook.getItems();
        
        loadPhoneBook(dataFile, phoneEntries);
        if (phoneEntries.size() == 0)
            phoneEntries.add( new PhoneEntry("name","number"));
        
        /* Define the table columns for the "Name" and "Phone Number" columns. */
        
        TableColumn&lt;PhoneEntry, String> nameColumn = new TableColumn&lt;>("Name");
        nameColumn.setCellValueFactory( new PropertyValueFactory&lt;PhoneEntry, String>("name") );
        nameColumn.setCellFactory( TextFieldTableCell.forTableColumn() );
        nameColumn.setPrefWidth(200);  // (Default size is too small)
        phoneBook.getColumns().add(nameColumn);
        nameColumn.setEditable(true);
        
        TableColumn&lt;PhoneEntry, String> numberColumn = new TableColumn&lt;>("Phone Number");
        numberColumn.setCellValueFactory( new PropertyValueFactory&lt;PhoneEntry, String>("number") );
        numberColumn.setCellFactory( TextFieldTableCell.forTableColumn() );
        numberColumn.setPrefWidth(200);  // (Default size is too small)
        phoneBook.getColumns().add(numberColumn);

        /* Finish making the GUI, with "Add" and "Delete" buttons placed into
         * the window below the table. */
        
        TextField nameInput = new TextField();
        nameInput.setPrefColumnCount(10);
        nameInput.setPromptText("(name)");
        TextField numberInput = new TextField();
        numberInput.setPromptText("(number)");
        numberInput.setPrefColumnCount(10);

        Button deleteButton = new Button("Delete Selected Entry");
        deleteButton.setOnAction( e -> {
            int selected = phoneBook.getSelectionModel().getSelectedIndex();
            if (selected >= 0)
                phoneEntries.remove( phoneBook.getSelectionModel().getSelectedIndex());
        });
        deleteButton.setMaxWidth(Double.POSITIVE_INFINITY);
        deleteButton.disableProperty().bind(
                phoneBook.getSelectionModel().selectedIndexProperty().isEqualTo(-1));
        Button addButton = new Button("Add:");
        addButton.setOnAction( e -> {  // add a new row to the table
            String name = nameInput.getText().trim();
            String number = numberInput.getText().trim();
            if (name.length() == 0 ) {
                    // Don't allow empty name in the table
                error("You must enter a name and number before adding an entry.");
                nameInput.requestFocus();
                return;
            }
            if (number.length() == 0 ) {
                    // Don't allow an empty phone number in the table
                error("You must enter a name and number before adding an entry.");
                numberInput.requestFocus();
                return;
            }
            nameInput.setText("");   // empty the input boxes, since the data has been
            numberInput.setText(""); //        copied into the table
            PhoneEntry newEntry = new PhoneEntry(name,number);
            phoneEntries.add( newEntry );
            phoneBook.scrollTo(phoneEntries.size() - 1); // make sure new row is visib.e
            phoneBook.getSelectionModel().select(phoneEntries.size() - 1); // highlight new entry
        });
        HBox add = new HBox(8,addButton,nameInput,numberInput);
        add.setPadding( new Insets(5) );
        VBox buttons = new VBox(add,deleteButton);
        buttons.setStyle("-fx-border-color:black; -fx-border-width: 2px");
        
        BorderPane tableHolder = new BorderPane(phoneBook);
        tableHolder.setBottom(buttons);
        
        stage.setOnHidden( e -> savePhoneBook(dataFile, phoneEntries) );
        
        stage.setScene( new Scene(tableHolder) );
        stage.setTitle("Phone Book Editor");
        stage.show();
        
    } // end start();
    
    
    /**
     * If the data file already exists, load the entries from the data
     * file in the list (which is the items list from the TableView).  
     * The format of the file must be as follows:  Each line of the file 
     * represents one directory entry, with the name and the number for that 
     * entry separated by the character '%'.  If a file exists but does not
     * have this format, then the program terminates; this is done to
     * avoid overwriting a file that is being used for another purpose.
     */
    private void loadPhoneBook(File dataFile, List&lt;PhoneEntry> entries) {
        if ( ! dataFile.exists() ) {
            message("No phone book data file found.  A new one\n"
                        + "will be created when the program ends,\n"
                        + "if you add any entries to the table.\n"
                        + "File name:\n    " + dataFile.getAbsolutePath());
        }
        else {
            try( Scanner scanner = new Scanner(dataFile) ) {
                while (scanner.hasNextLine()) {
                    String phoneEntry = scanner.nextLine();
                    int separatorPosition = phoneEntry.indexOf('%');
                    if (separatorPosition == -1)
                        throw new IOException("File is not a phonebook data file.");
                    String name = phoneEntry.substring(0, separatorPosition);
                    String number = phoneEntry.substring(separatorPosition+1);
                    entries.add( new PhoneEntry(name,number) );
                }
            }
            catch (IOException e) {
                error("Error in phone book data file.\n"
                            + "This program cannot continue.\n"
                            + "Data File name: \n   " + dataFile.getAbsolutePath());
                System.exit(1);
            }
        }
    }
    
    
    /**
     * Write the phone book entries from the list to the data files.
     * But if the list is empty, don't write anything.
     */
    private void savePhoneBook(File dataFile, List&lt;PhoneEntry> entries) {
        if (entries.size() == 0)
            return;
        System.out.println("Saving phone directory to file " + 
                dataFile.getAbsolutePath() + " ...");
        PrintWriter out;
        try {
            out = new PrintWriter( dataFile );
        }
        catch (IOException e) {
            error("ERROR: Can't open data file for output."
                    + "Phone book data cannot be saved.");
            return;
        }
        for ( PhoneEntry entry : entries ) {
            out.println( entry.nameProperty().get() + "%" + entry.numberProperty().get() );
        }
        out.flush();
        out.close();
        if (out.checkError())
            error("ERROR: Some error occurred while writing the data file."
                    + "Phone book data might not have been saved correctly.");
    }
    
    
    /**
     *  A utility method for showing an informational message to the user.
     */
    private void message(String text) {
        Alert alert = new Alert(Alert.AlertType.INFORMATION, text);
        alert.setHeaderText(null);
        alert.showAndWait();
    }
    
    /**
     *  A utility method for showing an erro message to the user.
     */
    private void error(String text) {
        Alert alert = new Alert(Alert.AlertType.ERROR, text);
        alert.setHeaderText(null);
        alert.showAndWait();
    }
    
    
} // end PhoneDirectoryGUI
</prog></pre>
</exercise-code>
</exercise>
         
</exercises>